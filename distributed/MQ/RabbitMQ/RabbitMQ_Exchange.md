## <center>RabbitMQ 交换器Exchange</center>

### 1. 交换器分类

RabbitMQ的Exchange分为四类:

- direct(默认)
- headers
- fanout
- topic

其中header交换器允许匹配AMQP消息的header而非路由键, 除此之外header交换器和direct交换器完全一致, 但是性能很差, 几乎用不到, 所以这里不作讲解。

#### 1.1 direct交换器

direct为默认的交换器类型, 如果路由键匹配, 消息就投递到相应的队列。

持续消息获取使用: ```java basic.consume```; 单个消息获取使用: ```java basic.get```。

##### 1.1.1 公平调度

当接收端订阅者有多个时, direct会轮询公平的分发给每个订阅者(订阅者消息确认正常)。

##### 1.1.2 消息的发后既忘特性

发后既忘是指接受者不知道消息的来源, 如果想要指定消息的发送者, 需要包含在发送内容里面。

##### 1.1.3 消息确认

如果程序接收了消息, 但是忘记确认接收时, 消息在队列的状态会从"Ready"变为"Unacked"。如果消息收到为确认, Rabbit将不会给这个程序发送更多的消息, 因为Rabbit认为你没有准备好接收下一条消息, 此条消息会一直保持Unacked状态, 直到你确认了消息, 或者断开Rabbit的连接。

**但是利用这一点, 可以让程序进行延迟确认消息, 知道程序处理完相应的业务逻辑, 可以有效的防止Rabbit给你过多的消息, 导致程序崩溃。**

但是无论如何, 消费者消费的每条消息都必须确认!

##### 1.1.4 消息拒绝

消息拒绝有两种:

- 断开与Rabbit的连接, 这样Rabbit会重新把消息分派给另一个消费者。
- 通过代码方式拒绝消息, 这样Rabbit会把消息发送到一个特殊的"死信"队列, 用来存放被拒绝而不重新放入队列的消息。

#### 2. fanout交换器 ———— 发布/订阅模式

fanout有别于direct交换器, fanout是一种`发布/订阅`模式的交换器。当发送一条消息时, 交换器会消息广播到所有跟这个交换器有关的队列上。

fanout和direct的区别最多是在接收端, fanout需要绑定队列到对应的交换器用于订阅消息。

**对于fanout交换器来说, routingKey(路由键)是无效的, 这个参数是被忽略的。**

#### 3. topic交换器————匹配订阅模式

topic交换器与fanout类似, 但是可以更加灵活的匹配自己想要订阅的信息, 需要使用`routingKey`路由键进行消息(规则)匹配。