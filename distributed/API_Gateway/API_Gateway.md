## <center>API 网关</center>

> 为什么需要网关?

在微服务开发中, 一个系统被拆分为多个服务, 但是向`安全认证`, `流量监控`, `日志`等功能都是每个服务都需要的, 如果没有网关, 我们就需要在每个服务中单独实现。所以一般情况下, **网关都会提供请求转发, 安全认证, 流量控制, 负载均衡, 容灾, 日志, 监控, 还有对请求的过滤, 权限校验等功能**。

- RPC协议转为HTTP协议

    我们知道在一个系统内部开发都是以`RPC协议`进行通信, 但是当外部服务需要使用这个接口时往往需要将RPC协议转为HTTP协议。

- 请求路由

    在微服务系统中, 如果需要调用多个微服务接口, 我们需要通过ip加上端口号, 再加上服务名称, 在加上api接口路径去请求, 这样每一个服务都有一个端口号, 服务名称, 不易维护与修改, 所以每个服务使用一个统一的前缀在作为服务请求的路由, 更易于开发。

### 1. 统一网关的设计

#### 1.1 异步化请求

对于统一网关的设计, 需要思考的是如何用少量的机器接入更多的服务, 这时候就需要异步操作, 来提高更多的吞吐量。

- Tomcat/Jetty+NIO+servlet
- Netty+NIO

Netty是为高并发而生的, 但是Netty需要自己处理HTTP协议, 所以比较麻烦。

对于网关是HTTP请求场景比较多的情况可以采用Servlet, 如果重视吞吐量可以采用Netty。

#### 1.2 链式处理

在设计模式中有一个**责任链模式**, 它的作用是避免请求发送者与接受者耦合在一起, 让多个对象都有可能接收到请求, 将这些对象连接成一条链, 并且沿着这条链传递请求, 知道有对象处理它为止。在Servlet里面的filter, SpringMVC中的Interceprot。

在SpringCloud Netflix Zuul中也用了这种模式:

- `preFilters`: 前置过滤器, 用来处理一些公关的业务, 比如统一鉴权, 统一限流, 熔断降级, 缓存处理等, 并且提供业务方扩展。
- `rountingFilters`: 用于处理泛化调用, 主要是做协议的转换, 请求的路由。
- `postFilters`: 后置过滤器, 主要用来做结果的处理, 日志处理, 记录时间等。
- `erroeFilter`: 错误过滤器, 用来处理调用异常的情况。

#### 1.3 业务隔离

如果使用自定义的filter中进行了某些同步调用, 一旦超时频繁就会对其他业务产生影响，所以我们需要采用隔离方式, 降低业务之间的相互影响。

##### 1.3.1 信号量隔离

信号量隔离只是限制了总的并发数, 服务还是主线程进行同步调用, 如果远程调用超时依然会影响主线程, 从而影响其他业务。

##### 1.3.2 线程池隔离

不同业务之间通过不同的线程池进行隔离, 就算业务接口出现了问题, 由于线程池进行了隔离, 也不会影响其他业务。比如: 商品或者订单都是单独的线程池去处理。

##### 1.3.3 集群隔离

如果某些业务就需要使用隔离但是没有统一网关,也没有线程池隔离, 那就使用集群隔离, 为某些业务单独申请一个集群或者多个集群, 通过机器进行隔离。

#### 1.4 请求限流

流量限制可以使用开源的实现, 比如阿里的`Sentinel`和比较成熟的`Hystrix`。

#### 1.5 熔断降级

也可以采用阿里的`Sentinel`和比较成熟的`Hystrix`。

#### 1.6 泛化调用

泛化调用指的时一些通信协议的转换, 比如HTTP转为Thrift。 淘宝支持HTTPS, HTTP1, HTTP2转换成 HTTP,HSF,Dubbo等协议。

> 如何实现泛化调用?

简单来说就是把两个协议都能转换成共同语言, 从而互相转换。

一般来说有三种方式:

- json: json数据比较简单, 解析速度快, 较轻量级。
- xml
- 自定义描述语言

### 2. 定制路由

上面我们知道网关的一个重要功能就是请求路由, 所以我们需要定制路由的规则。

- 路由表中包含源路径(一般是域名或者ip地址+端口号), 微服务名称, 目标路径(api接口路径)
- Endpoint粒度配置支持
- 路由支持1对1精确路由
- 源路径可以用`前缀/**`格式来模糊路由。
- 保留默认动态路由规则: `服务名称/**` -> 是否截去前缀 -> 目标路径
- 保留动态路由规则是否截去前缀的配置参数`stripPrefix`特性
- 路由规则可以在不重启服务动态更新


