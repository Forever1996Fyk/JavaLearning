## RPC 基础知识

### 1. 什么是RPC? 

**RPC(Remote Procedure Call) 远程过程调用**: 一种通过网络从远程计算机程序上请求服务, 而不需要了解底层网络技术的协议。RPC的出现就是为了调用远程方法像调用本地方法一样简单。

### 2. RPC的原理是什么?

#### 2.1 远程调用服务的过程

(1) 服务消费者(client)以本地调用方式调用服务;

(2) 客户端存根(client stub) 接收到调用后负责将方法, 参数等组装成能够进行网络传输的消息体;

(3) client stud 找到服务地址, 并将消息发送到服务端;

(4) 服务端存根(server stud) 收到消息后进行解码;

(5) server stud 根据解码结构调用本地的服务;

(6) 本地服务执行并将结果返回给server stud;

(7) server stud将返回结果打包成消息并发送至消费者;

(8) client stud 接收到消息, 并进行解码;

(9) 服务消费者得到最终结果。

**RPC的目的就是把2-8这些步骤都封装起来, 让用户忽略这些细节。**

![RPC过程](/image/RPC过程.jpg)

#### 2.2 Java如何透明化远程服务调用?

对于Java来说就是使用代理! Java代理方式有两种: jdk动态代理; 字节码生成。

虽然字节码实现的代理更为强大和高效, 但是代码维护不易, 所以大部分都是选择动态代理的方式。

#### 2.3 RPC解析

##### 2.3.1 发送消息数据结构

1. 接口名称:

如果不传, 服务端就不知道调用哪个接口了;

2. 方法名:

一个接口内可能有很多方法, 如果不传方法名服务端就不知道调用哪个方法;

3. 参数类型&参数值:

参数类型有很多, 例如: boolean, int, long, double, string, map, list 以及相应的参数值;

4. 超时时间

5. requestID:

请求id唯一标识。

##### 2.3.2 序列化

1. 什么是序列化?

序列化就是讲数据结构或对象转换成二进制串的过程, 也就是编码的过程。

2. 什么是反序列化?

将序列化过程中所产生的二进制串转换成数据结构或者对象的过程。

3. 为什么需要序列化?

转换成二进制串后才容易进行网络传输。

4. 为什么需要反序列化?

将二进制转换为对象才容易进行后续业务上的处理

##### 2.3.3 通信

消息数据结构被序列化为二进制串后, 就需要进行网络通信。目前常用的两种IO通信模型: BIO, NIO。大部分RPC框架都是使用NIO。

(1) 使用Java自带的NIO, 这种方式比较复杂, 而且有可能出现隐藏BUG
(2) 基于mina, 
(3) 基于Netty， 实例: dubbo, HSF, finagle等。

##### 2.3.4 为什么要有requestID?

整个远程调用的过程, 即从发出请求到接收到结果, 这是一个异步的过程。也就是说, 对于当前线程, 将请求发送出去后, 线程就去处理其他任务, 至于服务端的结果, 是服务端处理完成后, 再以消息的形式发送给客户端。所以这里有两个问题:

- 如何让当前线程"暂停", 等结果回来后, 在向后执行?
- 多个线程同时进行远程方法调用, 调用顺序随机, 服务端处理完返回结果发送给客户端, 那么客户端怎么知道哪个消息结果是哪个线程调用的?

> 如何解决? 发送消息与接收消息线程的一致性

1. client线程每次调用远程接口前, 生成一个唯一的ID, 即requestID(requestID必须保证在一个连接里是唯一的),一般常常使用AtomicLong从0开始累计数字生成唯一ID;
2. 将处理结果的调用对象callback, 存放到全局的`ConcurrentHashMap`中(put(requestID, callback));
3. 当线程调用发送消息后, 立马执行callback的get()方法尝试获取远程返回的结果, 如果没有获取到, 就调用wati()方法, 释放callback的锁, 让线程处理等待状态;
4. 服务端接收并返回结果时, response中包含requestID发送给客户端。client接收到消息, 获取requestID, 在从`ConcurrentHashMap`中get(requestID), 找到callback对象,
再用`synchronized`获取callback上的锁, 将方法调用结果传入到callback对象里, 在调用callback.notifyAll()唤醒等待的线程。


### 3 发布服务?

如何让别人使用我们的服务? 从原理上，只需要告诉使用者服务的IP以及端口号即可。但是关键是在于是自动告知还是人为告知。当然是自动告知。

人为告知: 如果对服务的需要不断的添加，删减。开发者就需要不断的手动修改代码来处理。

自动告知: 提供一个服务注册表, 让多个服务提供者形成一个集群, 服务消费者可以通过服务注册表获取具体的访问地址。

例如: zookeeper提供了"心跳检测"功能, 他会定时的想每个服务提供者发送一个请求, 就是建立一个socket长链接。如果长期没有响应, 服务注册中心就认为该服务已经挂了, 并将其踢出。更重要的是zookeeper优秀的容错容灾能力, 确保服务注册表的高可用性。

### 4. 既然有HTTP, 为什么还用RPC进行服务调用?

RPC只是一种设计概念而已, 是为了解决不同服务之间的调用问题。

HTTP是一种协议, RPC框架可以使用HTTP协议作为传输协议或者直接使用TCP作为传输协议, 使用不同的协议一般也是为了适应不同的场景。

> 很多人可能觉得, 是效率问题。但是所谓的效率优势是针对http1.1协议的, http2.0协议已经优化了编码效率问题。

我们知道对于客户端与服务端之间的连接, 要求的就是一点, 客户端发送请求, 服务端接收请求, 然后返回结果即可。如果服务端挂了, 客户端就是自然而然的请求失败, 并不需要过多的要求, 所以用http完全是没问题的;

但是对于服务端与服务端之前的通信, 虽然分提供者和消费者, 但是本质上都是属于服务端, 它们之间的通信不仅仅是需要简单的数据传输, 甚至还需要更高级的功能包括: **服务发现**, **容错**, **降级**, **错误重试**等等问题的解决。

所以rpc调用时面向服务的封装, 针对服务的可用性和效率多做了优化, 而单纯的使用http调用就缺少了这些特性。

