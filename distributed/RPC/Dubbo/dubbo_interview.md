## Dubbo 相关面试题

### 1. 你是否了解SPI, 能聊一聊SPI, 为什么要用SPI?

SPI是一种服务发现机制, 它的实现是当服务的提供者提供服务接口的一种实现之后, 在相应的目录(JDK是`META-INF/services`, Dubbo是`META-INF/dubbo`)下创建一个以服务接口命名的文件, 该文件就是实现这个服务接口的具体实现类的全限名。

这样做的好处就是: **当程序装配这个模块时, 就能通过这个配置文件找到具体的实现类名, 并装载实例。也就是说在运行时, 可以动态的给接口添加实现类。这样就能很好的找到服务接口的实现类, 而不需要在代码里写死。**

API是将方法封装起来给调用者使用, 而SPI是给扩展者使用。

### 2. 对类加载机制了解吗, 说一下什么是双亲委托模式, 有什么弊端。这个弊端有没有熟悉的案例, 如何解决这个弊端？

### 3. Dubbo的SPI和JDK的SPI有什么区别吗?具体说一下

Dubbo的扩展点加载是基于JDK的标准SPI扩展点发现机制增强的, Dubbo改进了JDK标准SPI的一些问题:

- JDK标准的SPI会一次性实例化所有实现, 如果有扩展实现初始化很耗时, 或者没用上的实现也会加载, 就会浪费资源
- 增加了IOC和AOP的支持, 一个扩展点或者实现实例,可以直接setter注入其他扩展点

### 4. Dubbo中SPI也增加了IOC, 先谈谈Spring的IOC, 然后在谈谈Dubbo是怎么做的?

Spring IOC是具有依赖注入功能的容器, 负责对象的实例化, 以及配置程序中对象与对象之间的依赖。通常我们new一个实例, 控制权有程序员控制, 而"控制反转"是指new实例的工作不由程序员实现,而是交给IOC容器。

Dubbo IOC是通过setter方法注入依赖。Dubbo先通过反射获取实例的所有方法, 然后在遍历方法列表, 检测方法名是否具有setter方法的特性。如果有的话,就通过`ObjectFactory`获取依赖对象, 最后通过反射调用setter方法将依赖设置到目标对象中。

### 5. Dubbo中SPI还增加了AOP, 这里面用了什么设计模式, Dubbo如何做的?

Dubbo SPI 的AOP功能是使用装饰者模式。 通过Dubbo扩展机制的中的Wrapper类, Wrapper类是一个有复制构造函数的类, 就是类A中有一个构造函数, 这个构造函数的参数就是A本身。
```java
class A{
    private A a;
    public A(A a){
        this.a = a;
    }
}
```

**通过使用包装类包装原始的扩展点实例, 也就是服务接口, 在原始扩展点实现前后插入其他逻辑, 实现AOP功能。**

例如`ProtocolFilterWrapper`代码如下: 它有一个构造函数, 参数是原始扩展点`Protocol`, 可以在这个`Protocol`前后添加相应逻辑。

```java
public class ProtocolFilterWrapper implements Protocol {

    private final Protocol protocol;

    // 有一个参数是Protocol的复制构造函数
    public ProtocolFilterWrapper(Protocol protocol) {
        if (protocol == null) {
            throw new IllegalArgumentException("protocol == null");
        }
        this.protocol = protocol;
    }
}
```

### 6. Dubbo角色和设计是怎样的, 原理是什么?

1. 服务提供者启动时向注册中心注册提供的服务, 并与注册中心建立长连接
2. 服务消费者启动时向注册中心订阅服务地址列表, 并与注册中心建立长连接, 如果服务地址变化, 注册中心可以实时推送变更的服务地址列表
3. 服务消费者随机调用一个服务地址, 失败重试另一个地址
4. Dubbo监控后台定时采集服务调用次数和调用时间等信息 

### 7. 有没有考虑自己实现一个dubbo的RPC框架?你会怎样实现?(面试高频题, 区分度高)

我本人没有自己实现过, 但是看过其他大佬自己手写一个类似dubbo的RPC框架。

可以从两个方面去入手, 

- 考虑接口扩展性, 改造JDK的SPI机制来实现自己的扩展SPI机制。
- 从动态代理入手, 比如网络通信, 编码解码这些步骤用动态代理的方式织入远程调用方法中, 实现透明化的调用

### 8. 用过mybatis是否知道Mapper接口的原理吗?(如果回答得不错,并且提到动态代理这个关键词会继续往下问,那这个动态代理又是如何通过依赖注入到Mapper接口的呢?)

MyBatis通过一个interface, 不需要编写实现类, 就可以返回接口实例的原理就是**动态代理**。通过生成接口的代理对象, 实现实例化接口并返回数据。

生成的代理对象通过MyBatis的`MapperFactoryBean`类, 这个类实现了`FactoryBean`接口, Spring通过调用这个类的`getObject()`方法实例化代理对象, 然后注入到Mapper上。

### 9. 服务发布过程中做了哪些事?

暴露本地服务, 暴露远程服务, 连接注册中心, 监听注册中心

### 10. Dubbo都有哪些协议, 它们之间有什么特点, 缺省值是什么?

Dubbo支持多种协议, 默认使用的是`dubbo`协议。Dubbo缺省协议采用单一长连接和NIO异步通信, 适合小数据量大并发的服务调用, 以及服务消费者数远大于服务提供者数的情况。

Dubbo缺省协议不适合传送大数量的服务, 比如:传文件, 传视频, 除非请求量很低。

### 11. 什么是本地暴露和远程暴露, 它们的区别?

在Dubbo中我们的一个服务可能既是提供者, 又是消费者。因此就存在自己调用自己服务的情况, 如果此时还通过网络去访问, 那显然是不合适的。

- 本地暴露是暴露在JVM中, 不需要网络通信。
- 远程暴露是将ip, 端口等信息暴露给远程客户端, 调用时需要网络通信。

### 12. 一般选择什么注册中心, 还有别的选择吗?

常用的是`zookeeper`, 其他还有`Multicast`, `redis`, `Simple`等

### 13. Dubbo中zookeeper做注册中心, 如果注册中心集群都挂掉, 那提供者和订阅者还能通信吗?(面试高频题)

`zookeeper`的信息会缓存到服务器本地作为一个cache缓存文件, 并转换为properties对象方便使用, 每次调用时, 按照本地存储的地址进行调用, 但是无法从注册中心去同步最新的服务列表。所以注册中心短期的挂掉是不要紧的, 但前提是没有增加新的服务, 如果你要调用新的服务, 是办不到的。

### 14. 项目中有使用过多线程?有的话讲讲你在哪里用到了多线程?(面试高频题)

建立线程池, 定时的检测并连接注册中心, 如果失败了就重连, 其实也就是一个定时任务执行器。

### 15. 服务提供者能实现失效踢出是什么原理?(高频题)

在分布式系统中, 我们需要知道某个机器是否可用, 一般开发我们可以通过ping某个主机来先实现, Ping的通说明对方是可用的。

在`Zookeeper`中让所有机器都注册一个临时节点, 判断一个机器是否可用, 我们只需要判断这个节点在`Zookeeper`是否存在就可以了。

### 16. zookeeper有哪些节点, 它们有什么区别?讲一下应用场景?

zookeeper中的节点有生命周期, 具体的生命周期取决于节点的类型, 节点主要分为4中: `持久节点`, `持久顺序节点`, `临时节点`, `临时顺序节点`。

- 持久节点: 就是节点创建后, 就一直存在, 知道有删除操作来主动清楚这个节点, 不会因为创建该节点的客户端会话失效而消失。
- 临时节点: 如果客户端会话失效, 那么这个节点就会被自动清除

### 17. 描述一下Dubbo服务引用过程, 以及原理?

Dubbo服务引用的时机有两个: 

1. 饿汉式加载, 即在Spring容器调用`ReferenceBean`的`afterPropertiesSet`方法时引用服务
2. 懒汉式加载, 即在`ReferenceBean`对应的服务被注入到其他类中时引用

默认情况下, Dubbo使用懒汉式引用服务。如果需要使用饿汉式, 可以通过配置`<dubbo:reference>`的init属性开启。


服务引用的流程为: **当我们的服务被注入到其他类中时, Spring会调用`ReferenceBean`的`getObject`方法，该方法是执行服务引用逻辑。在执行之前需要先进行配置检查与收集工作。根据收集的信息决定服务调用的方式, 有三种, 第一种是引用本地(JVM)服务, 第二种是通过直连方式引用远程服务, 第三种是通过注册中心引用远程服务。但是不管使用哪种方式最后会得到一个`Invoker`实例。如果有多个注册中心, 多个服务提供者, 会得到一组`Invoker`实例, 此时需要使用l类`Cluster`将多个`Invoker`合并成一个实例。`Invoker`实例具备调用本地或远程服务的能力, 但是并不能将`Invoker`实例暴露给用户使用, 因为会对用户业务代码造成侵入。此时框架还需要通过代理工厂类(ProxyFactory)为服务接口生成代理类, 并让代理类去调用`Invoker`逻辑。**

### 18. 既然你提到了Dubbo的服务引用中封装通信细节是用到了动态代理, 那请问创建动态代理的方式有哪些, 他们有什么区别?Dubbo用的是哪一种?(高频题)

动态代理实现有JDK, CGLIB, Javassist。

- JDK的动态代理对象必须要实现一个接口, 而针对没有接口的类, 可以使用CGLIB。
- CGLIB原理是对指定的目标类生成一个子类, 并覆盖其中方法实现增强, 但由于采用的是继承, 所以不能对final修饰的类进行处理。
- javassist通过生成字节码来实现代理。(dubbo多出用到了javassist)

### 19. Dubbo提供了哪几种集群容错模式?

Dubbo主要提供5中容错方式:

- Failover Cluster - 失败自动切换
- Failfast Cluster - 快速失败
- Failsafe Cluster - 失败安全
- Failback Cluster - 失败自动恢复
- Forking Cluster - 并行调用多个服务提供者

### 20. Dubbo中负载均衡算法以及特点?最小活跃数算法中是如何统计活跃数的？简单谈谈一致性哈希算法(高频题)

这里参考[Dubbo 负载均衡](/distributed/RPC/Dubbo/dubbo_loadbalance.md)这篇文章


### 21. 怎么通过Dubbo实现服务降级的, 降级的方式有哪些, 有什么区别?

当网站处于高峰期时, 并发量大, 服务能录有限, 那么我们只能暂时屏蔽边缘业务, 所以需要采用服务降级策略。

Dubbo中的服务降级分成两个: 屏蔽(mock=false), 容错(mock=fail)。

- `mock=force:return+null`: 表示消费者对该服务方法的代用都直接返回null值, 不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响
- `mock=fail:return+null`: 表示消费者对该服务的方法调用失败后, 再返回null值, 不抛出异常。用来容忍不重要服务不稳定时对调用方的影响

### 22. Dubbo监控平台能够动态改变接口的一些设置, 其原理是什么?

通过改变注册在zookeeper上的节点信息, 从而zookeeper通知重新生成invoker。