## Redis基本知识

`Redis`全称为 **`Remote Dictionary Server`(远程数据服务)**, 该软件使用C语言编写, Redis是一个key-value存储系统。

### 1. Redis特点

`Redis`是用内存作为数据存储介质, 所以读写数据的效率很高。(直接放在磁盘上需要进行IO操作, 很耗时)。

> 例如: 设置和获取一个256字节字符串, 它的读取速度可达到110000次/s, 写速度高达81000次/s

Redis与memcache不同的是, Redis中的数据是可以持久化的, 因为Redis的存储分为**内存存储, 磁盘存储, log文件**, 重启后, Redis可以从磁盘重新将数据加载到内存中。

Redis支持主从模式, 可以配置集群, 达到高可用。

### 2. Redis的优势

1. 处理数据速度快, 因为数据存在内存中;

2. 支持多种数据类型, 支持String, List, Set, Sorted Set(zrange), Hash;

3. 支持事务, 操作都是原子性的;

4. 使用场景多, 可用于缓存, 消息, 按key设置过期时间...

### 3. Redis使用场景

#### 3.1 会话缓存

可以使用redis来实现`Session Cache`会话缓存, 它比memcached的优势就在于, redis提供持久化。

例如: 购物车, 用户登录信息...

#### 3.2 消息队列

Redis在内存存储一个大优点是提供了list和set操作, 可以利用这个性质, Redis能作为一个很好的消息队列平台使用

#### 3.3 排行榜/计数器

Redis也有对数字进行递增或递减的操作实现。集合(Set)和有序集合(Sorted Set)两种数据结构可以实现这个操作。

例如: 我们从以分数排序集合中获取排名最前的10个用户"user_scores", 使用下面命令即可:

```shell
zrange user_scores 0 10 withscores
```

这里还涉及到Redis的淘汰策略! 例如下面的例子:

> MySQL里有2000w数据, redis中只存20w数据, 如何保证redis中的数据都是热点数据?

**当redis内存数据集大小达到一定大小时, 就会执行淘汰策略。Redis提供6中数据淘汰策略:**

1. `volatile-lru`: 从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰;

2. `volatile-ttl`: 从已设置过期时间的数据集(server.db[i].expires)中挑选要过期的数据淘汰;

3. `volatile-random`: 从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰;

4. `allkeys-lru`: 从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰;

5. `allkeys-random`: 从数据集(server.db[i].dict)中任意选择数据淘汰;

6. `no-enviction`: 禁止淘汰数据。

#### 3.4 发布/订阅

Redis的发布订阅有三个重要部分: 订阅者, 发布者, 频道channel。

客户端订阅某个频道channel后, 发布者就可以通过此channel发布消息, 所有丁月中都会收到发布的消息。

利用上面的特性, 我们可以在以下场景中使用:

1. 异步消息通知, 比如支付回调通知;

2. 任务通知;

3. 参数刷新加载;

众所周知，我们用Redis无非就是将系统中不怎么变的、查询又比较频繁的数据缓存起来，例如我们系统首页的轮播图啊，页面的动态链接啊，一些系统参数啊，公共数据啊都加载到Redis，然后有个后台管理系统去配置修改这些数据。
> 打个比方我们首页的轮播图要再增加一个图，那我们就在后管系统加上，加上就完事了吗？当然没有，因为Redis里还是老数据。那你会说不是有过期时间吗？是的，但有的过期时间设置的较长如24小时并且我们想立即生效怎么办？这时候我们就可以利用Redis的发布订阅机制来实现数据的实时刷新。当我们修改完数据后，点击刷新按钮，通过发布订阅机制，订阅者接收到消息后调用重新加载的方法即可。