## MySQL优化 -- 索引的优化

索引是数据库优化最常用也是最重要的手段之一, 通过所以通常可以帮助用户解决大多数的MySQL的性能优化问题。

### 1. 索引的使用

我们知道, 索引是以文件的形式存储在磁盘上的, 由于B+树的特性, 每一个节点其实都对应一个磁盘块。所以每一次查找数据都需要进行IO操作。IO的次数取决于B+树的高度。

当数据量一定的情况下, 高度越小, 每个磁盘块存储的数据量越多。

也就是说, **如果存储的数据量所占空间越小, 那么每个磁盘能够存储的数据量就越多, B+树的高度越低, 每次查找进行IO次数就会越少, 这也就是为什么索引字段要尽量的小。**

### 2. 索引使用原则

在使用索引时, 有很多要注意的点才能避免**索引失效。**

这也是SQL优化的重点！！！

#### 2.1 最左前缀匹配原则

对于使用组合索引时, 总是要从索引的最左边的字段开始, 依次往后, 中间不能跳过。

例如创建了组合索引`idx_name_age_sex(name, status, address)`, 会先匹配name字段, 在匹配status字段, 最后匹配address字段, 中间不能跳过, 否则只有name列会生效。

```sql
select * from table where name = '测试' and address = '北京市'
```

上面的的查询sql, 利用explain可以发现, 只会使用最左name索引列, 因为扫描了索引字段key_len只显示name的长度。

![mysql_optimization12](/image/mysql_optimization12.png)

mysql会一直向右匹配知道遇到范围查询(>, <, between, like)就停止匹配。

![mysql_optimization13](/image/mysql_optimization13.png)

我们可以看到, 当使用范围查询时, 索引字段长度, 只用到了name, age。

> 一般情况下, 判断组合索引中某个索引列是否生效, 就通过`key_len`属性。它表示使用索引字段的长度。组合索引则是所有索引列的长度之和。

#### 2.2 尽量选择区分度高的列作为索引

例如, 我们会选择用户的身份证号做索引,而不会选择性别来做索引。

因为字段的值类型越少(比如性别, 一般只会有两种类型的值, 要么男, 要么女)。如果作为索引, 根据B+树的结构, 它要保证数据项必须从小到大排序, 而由于区分度低的字段, 很难确定大小关系, 因为值都相等, 那么导致树的高度就很高, 极端情况下, 索引字段的值都一样, 那么B+树几乎成为了一条直线。这样查询就会进行全表扫描, 效率很低。

所以, 字段的区分度越低, 树的高度越高, IO次数越高, 查询效率也就越低。

> 1. 如果性别字段是sex只有两个值:0,1。那么如果条件是sex=2, 查询会很快, 因为索引树中时不存在2的值; 
> 2. 但是如果条件正好是sex=1, 查询时,我们很难从树的某个位置得到一个明确的范围, 只能往下找, 导致IO次数很多, 查询速度很慢。

#### 2.3 =和in可以乱序

比如, `where a = 1 and b = 2 and c = 3`, 建立(a, b, c)索引可以任意顺序, mysql的查询优化器会自动优化索引可以识别的形式。

#### 2.4 索引列不能参与计算

尽量的不要对索引列进行计算操作, 包括字符串截取之类。

因为每次查找时, 都会先将索引计算一次, 在做比较, 导致索引失效。

#### 2.5 尽量扩展索引, 不要新建索引

比如表中已经有a的索引, 现在要加(a,b)索引, 那么只需要修改原来的索引即可。

#### 2.6 字符串不加单引号, 会导致索引失效

由于在查询时, 没有对字符串加单引号, MySQL的查询优化器, 会自动的进行类型转换, 造成索引失效。

### 3. 索引优化总结

#### 3.1 解决索引失效

我们在使用索引时, 经常会出现有索引但是未被用到的情况。也就是**索引失效**

##### 3.1.1 Like的参数以通配符开头导致索引失效

当我们使用like时, 如果Like的参数是以通配符开头, 例如: `like '%xx'`, 那么数据库就放弃使用索引, 而进行全表扫描。

**所以使用like查询时, 不要以通配符开头, 也就是`like 'xxx%'`, 这就是使用了索引, 并且是范围查找。**

##### 3.1.2 where条件不符合最左前缀原则

之前我们也说过, 索引使用的原则, 要使用最左前缀原则。

##### 3.1.3 使用!= , <>操作符

尽量避免使用`!=`, `<>`操作时, 否则数据库引擎会放弃使用索引, 进行全表扫描。

使用`>`或`<`会比较高效

##### 3.1.4 避免索引列参与计算

应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

##### 3.1.5 对字段进行null值判断

应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描, 如:

```sql
select * from table where status is null
```

可以在字段上设置默认值0, 来确保索引列上没有null值:

```sql
select * from table where status = 0
```

##### 3.1.6 使用or连接条件

尽量避免在where子句中使用or来连接条件, 否则也会导致索引的失效。

一般情况下, 我们利用union all 来代替or查询:

低效:

```sql
select * from table where name = '测试' or status = 0
```

高效:

```sql
select * from table where name = '测试'
union all
select * from table where status = 0
```
 
 ##### 3.1.7 避免select *

 之前我们也说过, select * 会导致索引查询回表操作。尽量使用覆盖索引, 也就是只查询索引列。

 #### 3.2 order by 语句优化

 **任何在`order by`语句中使用非索引列, 都会降低查询速度。**

MySQL有两种排序方式:

1. **FileSort排序**: 通过返回数据进行排序, 所有不是通过索引直接返回排序结果的排序, 效率较低;

2. using index排序: 通过有序索引顺序扫描直接返回有序数据,不需要额外排序，操作效率高。

> 这也比较好理解, 索引结构是B+树, 本身就是有序的, 所以索引排序很简单; 但是非索引排序, 就需要额外的进行排序操作。

 优化的方式一般有两种:

 1. 为`order by`的字段, 建立索引;

 2. 避免在`order by`字句中使用表达式。

 但是在某些情况下, 必须要使用filesort排序时, 那就需要额外的操作来优化filesort。对于FileSort, MySQl有两种排序算法:

 - 两次扫描算法: MySQL4.1之前使用该方式排序。首先根据条件取出排序字段和行指针信息, 然后在排序区sort buffer中排序, 如果sort buffer不够, 则在临时表中存储排序结果。完成排序之后, 再根据行指针回表读取记录, 该操作可能会导致大量随机IO操作;

 - 一次扫描算法: 一次性取出满足条件的所有字段的值, 然后在排序区中排序后直接输出结果集。排序时内存开销较大, 但是排序效率比两次扫描算法要高。

 MySQL通过比较系统变量`max_length_for_sort_data`的大小和Query语句取出的字段值总大小, 来判定采用哪种排序算法。如果`max_length_for_sort_data`更大, 那么使用第二种优化的算法, 否则使用第一种。

 所以我们可以适当提高`sort_buffer_size`和`max_length_for_sort_data`系统变量, 来增大排序区大小, 提高排序的效率。

 #### 3.3 group by 语句优化

`group by`语句会先进行排序, 然后在进行分组操作; 如果在分组时还使用一些聚合函数, 那么还需要进行聚合函数的计算。所以在`group by`的实现过程中, 也可以利用索引。

如果查询使用`group by`, 但是不在乎排序的结果, 那么可以执行`order by null`禁止排序:

```sql
select age,count(*) from emp group by age order by null; 
```

#### 3.4 用exists 代替in

很多情况下, 可以使用`exists`代替in。

#### 3.5 使用varchar代替char

尽可能使用`varchar`代替`char`, 因为`varchar的字段存储空间更小, 节省存储空间。

#### 3.6 能用union all 就不用union

因为`union`会对最终的结果进行去重操作(执行`select distinct`), 如果对结果不需要去重, 就使用`union all`。

#### 3.7 优化分页查询

一般分页查询, 通过覆盖索引能够有比较好的性能。但是当数据量很大, 而分页的大小也很大时, 例如`limit 2000000, 10`, 
此时MySQL排序前2000010记录, 仅仅返回2000000~2000010的记录, 其他记录丢弃, 查询排序的代价很大。

优化思路有两点:

1. 只适用于主键自增的表, 可以把limit查询转换成某个位置的查询;

```sql
select * from table where i > 2000000 limit 10;
```

2. 在索引上完成排序分页操作, 最后根据主键关联查询其他列信息:

```sql
select * from table a, (select id from table b order by id limit 2000000, 10) b where a.id = b.id;
```




