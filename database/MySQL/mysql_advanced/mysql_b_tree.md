## MySQL原理解析--B Tree树

BTree是MySQL索引的最核心数据结构。这里主要是对BTree和B+Tree从增删改查方面进行深度的学习。

### 1. B Tree

B树也称为B-树, 是多路平衡查找树。当描述一颗B树时需要指定它的阶数, **阶数表示了一个节点最多有多少个孩子节点**, 一般用字母m表示阶数。当m取2时, 就是**二叉查找树**。

一颗m阶的B树定义如下:

1. 每个节点最多有m-1个关键字(在MySQL中可以理解为索引字段的值)

2. 根节点最少可以只有1个关键字

3. 非根节点最少有 **`Math.ceil(m/2)-1`** 个关键字;

4. 每个节点的关键字都按照从小到大的顺序排序, 每个关键字的左子树都小于它, 右子树都大于它;

5. 根节点到所有叶子节点的长度都相同.

![mysql_btree1](/image/mysql_btree1.png)

从上面的定义可以看出, BTree一定是排好序的, 而且一般都是从小到大排序。

上图就是一个阶数为4的B树。

- 一般实际应用中B树的阶数m都很大(通常大于100), 所以即使存储大量的数据, B树的高度也比较小。

- 每个节点存储了关键字(key)和关键字对应的数据(data), 以及指向孩子节点的指针;

- 在数据库中, 索引字段的值就对应关键字key, 而data表示这个该字段对应列数据在磁盘上的逻辑地址;

#### 1.1 BTree的插入操作

在B树中进行插入操作, 即key, data。如果B树中已存在需要插入的key, 则用新的data替换原data。

插入的操作如下:

1. 判断当前节点的key个数是否小于等于m-1, 若满足则直接插入, 否则进行第3步;

2. 以每个节点中间的key为中心, 分裂成左右两部分, 然后将中间的key插入到父节点中, 这个key的左子树指向分裂的左半部分, 右子树指向分裂的右半部分; 

3. 如果父节点的key个数也大于m-1, 则对父节点进行分裂;

我们以5阶B树为例, 来进行插入操作; 在5阶B树中, 节点最多有4个key, 最少有`Math.ceil(5/2) - 1 = 2`个key

***

a) 在空树中插入39

![mysql_btree2](/image/mysql_btree2.png)

此时根节点就一个key, 此时根节点就是叶子节点

***

b) 继续插入22, 97, 41

![mysql_btree3](/image/mysql_btree3.png)

按照B树是顺序的特点, 依次插入即可, 而且key数没有大于4.

***

c) 继续插入53

![mysql_btree4](/image/mysql_btree4.png)

插入53后, 超过了最大关键字数4, 所以以key值41为中心进行分裂, 分裂之后当前节点指向父节点; 如下图

> 当阶数m为偶数时, 分裂的中间节点就去中间位置的前一个或者后一个key即可。

![mysql_btree5](/image/mysql_btree5.png)

***

d) 依次插入13, 21, 40, 也同样会发生分裂, 结果如下:

![mysql_btree6](/image/mysql_btree6.png)

***

e) 依次插入30, 27, 36, 35, 34, 24, 29

![mysql_btree7](/image/mysql_btree7.png)

***

f) 插入26的值,

![mysql_btree8](/image/mysql_btree8.png)

此时当前节点需要以27为中心分裂, 并插入父节点, 然后当前节点指向父节点: 如下图:

![mysql_btree9](/image/mysql_btree9.png)

此时父节点也需要分裂, 分裂的结果如下:

![mysql_btree10](/image/mysql_btree10.png)

***

g) 最后再插入17,28,29,31,32的值, 最终结果如下图

![mysql_btree11](/image/mysql_btree11.png)

***

根据上面的B树的插入过程, 对于确定的m, 节点的大小是固定的, 无论实际存储了多少条记录。

> 但是分配固定节点大小的方法会存在浪费的情况。例如key为28, 29所在的节点, 还有2个key的位置没有使用, 但是已经不可能继续插入任何值, 因为该节点前继key是27, 后继key是30。所以不可能在有值插入。
这种情况的出现就会导致节点使用率很低, 最差的情况使用率只有50%。

### 2. B+ 树

B+树与B树的定义基本上相同, 只是在每个节点的数据组成上有所不同。

**B+树与B树的最大区别是, B+树的每个内部节点不保存数据, 只保存key值, 所有数据都保存在叶子节点中。所以叶子节点保存了所有的key值, 以及对应的数据**

除此之外, 每个叶子节点都存有相邻叶子节点的指针。下图就是一个B+树:

![mysql_b+tree1](/image/mysql_b+tree1.png)

m阶B+树表示了内部节点最多有m-1个关键字, 同时限制了每个叶子节点最多存储m-1个记录数据。

#### 2.1 B+树的插入操作

B+树的插入操作与B树基本相同, 最大的不同就是, 当产生分裂情况时, 向上进位的仅仅只有key, 而不包括data。

例如我们还是建立一个5阶B+树, 5阶B+树的节点最少2个key, 最多4个key

***

a) 空树插入5

![mysql_b+tree2](/image/mysql_b+tree2.png)

***

b) 依次插入8,10,15

![mysql_b+tree3](/image/mysql_b+tree3.png)

***

c) 插入16

![mysql_b+tree4](/image/mysql_b+tree4.png)

插入16后, 超过了关键字的个数限制, 所以要进行分裂。在分裂时, 分裂出来的左节点有2个记录, 右边3个记录, 中间key作为索引节点的key, 分裂后的当前节点指向父节点。

![mysql_b+tree5](/image/mysql_b+tree5.png)

当然也可以左节点3个记录, 右节点2个记录, 此时索引节点的key就是15.

***

d) 插入17, 18

![mysql_b+tree6](/image/mysql_b+tree6.png)

此时右节点关键字个数大于5, 进行分裂。中间的关键字16进位到父节点(索引类型), 左节点2个记录, 右节点3个记录。

![mysql_b+tree7](/image/mysql_b+tree7.png)

***

f) 当再次插入若干数据后, 得到的结构如下

![mysql_b+tree8](/image/mysql_b+tree8.png)

***

g) 在插入7时

![mysql_b+tree9](/image/mysql_b+tree9.png)

当前节点关键字超过4, 需要分裂。中间关键字7进位到父节点。

![mysql_b+tree10](/image/mysql_b+tree10.png)

而此时父节点的关键字也超过4个, 还需要继续分裂。中间关键字16进位到父节点中。如下图:

![mysql_b+tree11](/image/mysql_b+tree11.png)

### 3. BTree 与 B+Tree的比较

1. BTree的每一个内部节点都存储了key以及对于的数据, 而B+Tree只有叶子节点才存储数据。

2. BTree需要做中序遍历才能遍历整棵树, 而B+Tree只需要对叶子节点进行链表的遍历即可;

3. BTree不支持范围查询, 而B+Tree支持范围查询(range-query)。

> 以上的三点基本上就是MySQL为什么选用B+树, 而不用B树的原因
