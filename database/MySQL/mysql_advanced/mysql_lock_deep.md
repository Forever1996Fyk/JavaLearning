## MySQL原理解析 -- 锁机制

在数据库中, 数据基本上都是共享的方式提供出去, 既然是共享的, 很明显就会出现线程安全问题。**于是MySQL锁机制的出现, 解决数据并发访问的一致性, 有效性, 甚至对于锁本身也要解决锁冲突引发的并发访问性能问题。**

### 1. 锁分类

**从对数据操作的粒度分类:**

1. 表锁: 操作时, 会锁定整个表;

2. 行锁: 操作时, 会锁定当前操作行;

3. 间隙锁: 

**对数据操作的类型分类:**

1. 读锁(共享锁): 对同一条数据, 多个读操作可以同时进行而不会互相影响; 

2. 写锁(排它锁): 当前操作没有完成前, 会排斥其他获取写锁和读锁操作。

我们在学习多线程的锁`lock`时, 有一个`ReentrantReadWriteLock`就是读写锁的意思, 只有当所有的请求都是读操作时, 是不会阻塞其他线程; 但是只要存在写操作, 不管是读锁还是写锁, 都只能同时存在一个线程可以获取锁。

在MySQL中, 读锁与写锁的用法也是如此: 

读锁是共享锁, 只要是读操作就允许多个请求共同获取读锁; 但是如果是写操作, 则只会有一个请求获取锁, 其他请求必须等待锁的释放;

写锁是排它锁, 只要是获取到写锁, 其他请求不管是读操作还是写操作都只能等待写锁释放, 才能进行操作。


### 2. MySQL锁简介

MySQL的锁机制根据不同的存储引擎, 会支持不同的锁机制。

| 存储引擎 | 表级锁 | 行级锁 | 页面锁 |
| -- | -- | -- | --
| MyISAM | 支持 | 不支持 | 不支持 |
| InnoDB | 支持 | 支持 | 不支持 |
| Memory | 支持 | 不支持 | 不支持 |
| BDB | 支持 | 不支持 | 支持 |

MySQL这三种锁的特性大致如下:

| 锁类型 | 特点 |
| -- | -- |
| 表级锁 | 偏向MyISAM存储引擎, 开销小, 加锁快; 不会出现死锁, 锁定粒度大, 发生锁冲突的概率最高, 并发度最低 |
| 行级锁 | 偏向InnoDB存储引擎, 开销大, 加锁慢; 会出现死锁, 锁定粒度最小, 发生锁冲突的概率最低, 并发度最高 |
| 页面锁 | 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。|

根据上面的简介, 其实很难确定那种锁更好。只能说根据不同的业务需求采用不同的锁机制。

**从锁的角度来说, 表级锁更合适以查询为主, 只有少量按索引条件更新数据的应用; 而行级锁更适合大量按索引条件并发更新不同数据, 同时有需要查询的场景。**

### 3. MyISAM 表锁

`MyISAM`存储引擎只支持表锁。在执行哈讯语句(select)前, 会自动给涉及的所有表加读锁, 在执行更新操作(update, install, delete)前, 会自动给涉及的表加写锁, 这个过程不需要用户干预, 因此用户一般不需要直接用`lock table`命令给`MyISAM`表显式加锁。

> 显式加锁语法:
> - 加读锁:
>```sql
lock table table_name read;
>```
>
> - 加写锁:
> ```sql
lock table table_name write;
>```

`MyISAM`的读写锁调度时写优先, 也就是说, MyISAM不适合做写为主的表的存储引擎。因为获取写锁后, 其他线程不能做任何操作, 包括读取数据, 大量的更新会阻塞查询操作。


### 4. InnoDB 行锁

