## MySQL原理解析 - 深入理解索引Index

### 1. 什么是索引?

- 索引是一种提高数据库查询效率的数据结构;

- 索引一般存储在磁盘文件中, 它是占用物理空间的;

- 适当的索引能提高查询效率, 过多的索引会影响数据库表的插入和更新功能。

索引的本质是**通过不断的缩小想要获取数据的范围来筛选最终的结果。**

但是数据库要复杂的很多, 因为不仅面临等值查询, 还有范围查询(>, <, between, in)、模糊查询(like), 并集查询(or)等等。所以数据库也是采用分段查询。

> 最简单的如果1000条数据, 1到100分成第一段, 101到200分为第二段, 201到300分为第三段... 这样查询第250条数据, 只需要找第三段就可以了, 一下去除了90%的无效数据。
>
> 但是如果是1000万的数据, 应该怎么分?
> 
> 我们可能会想到搜索树, 平均复杂度是lgN, 查询性能也很不多错。但是数据库实现比较复杂。
> 
> **数据是保存在磁盘上的, 因为一般的搜索树(二叉查找树, 红黑树等)的深度过大, 而造成磁盘IO读写过于频繁, 导致效率低下。**

### 2. 索引的分类

索引一般从三个方面分类: **数据结构维度**, **物理存储维度**, **逻辑维度**

1. **数据结构维度**

    - B+树索引: 所有数据存储在叶子节点上, 复杂度为O(logn), 适合范围查询;

    - 哈希索引: 适合等值查询, 检索效率高;

    - 全文索引: 一般在文本类型char, text, varchar类型上创建;

    - R-Tree索引: 用来对GIS数据类型创建SPATIAL索引。

2. **物理存储维度**

    - 聚集索引: **聚集索引就是以主键创建的索引, 在叶子节点存储的是表中的行数据;**

    - 非聚集索引: **非聚集索引就是以非主键创建的索引, 在叶子节点存储的是主键和索引列的值;**

3. **逻辑维度**

    - 普通索引index: 加速查找

    - 唯一索引

        - 主键索引: primary key: 加速查找+约束(不能为空且唯一), 这也是默认的索引;
        - 唯一索引: unique: 加速查找+约束(可以有多个null, 且唯一)

    - 联合索引

        - primary key(id, name): 联合主键索引

        - unique(id, name): 联合唯一索引

        - index(id, name): 联合普通索引

    - 全文索引full text: 一般用于搜索很长的文章时, 效果更好

    - 空间索引: 一般不用

### 3. 为什么选择B+树作为索引结构

可以从多个维度去解决这个问题。查询是否够快, 效率是否稳定, 存储数据多少, 以及查找磁盘的IO次数。

从这几个维度我们可以依次的比较B+树与其他结构类型的优势。

#### 3.1 为什么不用哈希结构?

哈希结构类似于k-v结构, 也就是说key和value是一对一的关系, 它非常适用于**等值查询**, 但是范围查询哈希结构是无法解决的。

#### 3.2 我们不使用二叉树?

所谓二叉树, 就是每个节点最多有两个子树, 左子树和右子树。而且左子树的值小于当前节点, 右子树的值大于当前节点。

但是存在一种特殊的二叉树, 只有左子树或者右子树。二叉树特殊化为一个链表, 那么每次的查询都相当于全表扫描, 导致索引失效, 因此二叉树不适合作为索引结构

![mysql_index_deep1](/image/mysql_index_deep1.png)

#### 3.3 为什么不是平衡二叉树(AVL)或者红黑树(RB Tree)

平衡二叉树是二叉树的一种, 但是它通过左旋右旋的方式, 让任意节点的左右子树的高度差不超过1, 所以就不存在二叉树退化成链表的情况;

红黑树也是二叉树的一种, 他也是通过左右旋转以及变色的方式, 保证不退化成链表;

但是平衡二叉树与红黑树:

- 每次的插入和删除, 甚至更新都需要复杂的旋转操作维持平衡, 导致效率很低; 

- 如果数据过多, 又会导致树的高度很高, 因为数据是存在磁盘上的, 以它为数据结构, 每次从磁盘中读取一个节点, 操作IO的次数就很多。

#### 3.4  为什么不用B树

数据量大时, 平衡二叉树的高度很高, 会增加IO次数。而B树相对于平衡二叉树, 就可以存储更多的数据, 高度更低, 因为B树本身就是多路平衡二叉树。但是不选择的使用B树, 因为B+树是B树的升级:

- B+树非叶子节点是不存储数据的, 仅存储键值, 而B树节点不仅存储键值, 也会存储数据。InnoDB中页的默认大小是16KB, 如果不存储数据, 那么就会存储更多的键值, 那么对应数的阶数就可以更大, 树的高度会更低。这样, 我们查找数据进行磁盘的IO次数会更骚, 数据查询效率会更快;

- B+树索引的所有数据都存储在叶子节点, 而数据是按照顺序排列的, 每个数据都有前后指针连接,那么B+树可以更加简单的进行范围差早, 排序查找, 分组查找以及去重查找。

### 4. MySQL中B+树索引的应用

我们之前学习了[B+树](/database/MySQL/mysql_advanced/mysql_b_tree.md)的结构, 我们要知道B+树在MySQL中的运用时, 所存储的结构到底是怎样的?

1. 首先任何一个表的主键, 都是默认的索引, 称为主键索引, 或者是**聚族索引**。主键索引在B+树中, 叶子节点存储的键就是id值, 而存储的数据就是整个行数据row;

2. 而**建立普通索引(非聚族索引), 在B+树中, 叶子节点存储的键就是普通索引的值, 而存储的数据对应的是id值; (这是要注意的)**

    **<font color='red'>所以当我们用普通索引查询数据时, 会先通过普通索引的B+树, 找到id值, 然后在回到主键索引通过id找打对应的行数据。这个过程被称为回表。</font>**

    > 这也就是为什么不能使用 * 号作为查询结果。 因为使用 * 号会导致索引的回表操作。索引查询数据时尽量的查询索引字段。

### 5. MySQL中B+树索引搜索过程

假设有下面的表:

```sql
CREATE TABLE `employee` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `date` datetime DEFAULT NULL,
  `sex` int(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_age` (`age`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into employee values(100,'小伦',43,'2021-01-20','0');
insert into employee values(200,'俊杰',48,'2021-01-21','0');
insert into employee values(300,'紫琪',36,'2020-01-21','1');
insert into employee values(400,'立红',32,'2020-01-21','0');
insert into employee values(500,'易迅',37,'2020-01-21','1');
insert into employee values(600,'小军',49,'2021-01-21','0');
insert into employee values(700,'小燕',28,'2021-01-21','1');
```

**如果执行下面的sql, 需要执行几次树搜索操作?**

```sql
select * from Temployee where age=32;
```

我们先画出`idx_age`的索引, 也就是非聚族索引的结构图:

![mysql_index_deep2](/image/mysql_index_deep2.png)


在画出id主键索引, 也就是聚族索引的结构图:

![mysql_index_deep3](/image/mysql_index_deep3.png)


根据上面所说的, MySQL中B+树的结构, 也很简单的可以知道搜索的过程:

1. 搜索`idx_age`索引树, 将磁盘1加载到内存中;

2. 而由于32<37, 所以接着搜索左路分支, 将磁盘2加载到内存中, 在内存进行遍历, 找到age=32的记录, 获取值id=400;

3. 拿到id=400, 回到主键索引树;

4. 搜索`主键索引树`, 将磁盘1加载到内存中, 内存遍历, 找到400的记录;

5. 由于B+树索引的非叶子节点不保存数据, 所以索引会继续搜索400的右分支, 于是将磁盘3加载到内存中, 在内粗那种遍历, 找到id=400的记录, 拿到行数据返回。

所以上面的sql执行了3次数搜索操作:

1. `idx_age`搜索;

2. `id主键`搜索;

3. 叶子节点搜索。

### 6. 覆盖索引

针对第5点的sql, 如果不用`select *`, 而是使用`select id, age`, 那么会执行几次搜索操作?

我们可以看到, id, age都是索引字段, **如果sql查询的都是索引字段, 那么就称为覆盖索引查询。**

此时我们只要通过搜索`idx_age`的索引, 就直接可以得到对应的age，以及id值, 不需要进行回表操作。

> 覆盖索引: 在查询的数据列中, 不需要回表查询, 直接从索引列就能获取相应的结果。也就是查询的数据正好是索引列。

所以搜索的次数就变成2次了。

### 7. 大表添加索引

如果一张表的胡巨量是千万级别, 那么如何给这张表添加索引?

我们知道添加索引, 就是对某一列或者几列, 构造成B+树的结构。因此, 在给表添加索引时, 是需要对表加锁的, 此时是无法对表进行任何的操作。

所以对大表添加索引需要谨慎!!!

解决方法可以参考:

1. 先创建一张跟原表A数据结构相同的新表B;

2. 在新表B中添加索引;

3. 把原表A数据导入到新表B中;

4. 将新表B重命名为原表A, 把原表A更换成其他表名。

