## JVM堆--分代策略

在之前的文章中, 我们学习了JVM堆空间的年轻代和老年代, 以及后面要学习的方法区。那么为什么要把JAVA堆分代?不分代可以正常工作吗?

1. 不同对象的生命周期不同, 大部分对象都是临时对象。

    - 新生代: 有Eden, Survivor区构成

    - 老年代: 存放新生代经历多次依然存活的对象

2. 其实不分代也是可以的。**分代的唯一目的就是优化GC的性能。**因为我们知道一旦GC线程启动了就会STW(Stop the World), 影响用户线程, 所以优化GC性能很有必要。

    > 如果把所有对象都放在一块, GC的时候需要找到那些对象没用, 这样就会对堆的所有区域进行扫描, 导致GC时间过长; 如果进行分代, 把新创建的对象放在某一地方, 当GC时只需要专门处理对应的区域即可, 大大减少了GC的时间。

### 1. 内存分配策略

针对不同年龄段的对象分配, 有不同的策略:

- 新创建的对象优先分配到Eden区;

- 大对象(在进行YGC之后的Eden区仍然无法存放的对象), 直接分配到老年代;

- 长期存活的对象分配到老年代;

- 动态对象年龄判断。

    > 如果`Survivor`区中相同年龄(**每次移动幸存对象的分代年龄, 默认15**)的所有对象大小总和大于`Survivor`空间的一半, 年龄大于或等于该年龄对象可以直接进入老年代, 不需要等到`MaxTenuringThreshold`设置的年龄。

### 2. 空间分配担保机制

我们知道当Eden区没有足够空间进行分配是, JVM会进行一次Minor GC/YGC。如果在GC期间,发现其中对象无法存入Survivor区, 就可以通过**分配担保机制**, 把年轻代对象提前转移到老年代, 如果老年代空间足够存放对象, 就不会出现Major GC。执行Minor GC后, 后面分配对象如果能够存在Eden区的话, 还是会Eden区分配内存。

### 3. TLAB(堆中线程私有缓存区域)

**TLAB**是`Thread Local Allocation Buffer`的缩写:

- 我们知道堆空间是线程共享区域, 任何线程都可以访问到堆区找那个的共享数据。由于对象实例的创建在JVM中非常频繁, 因此在并发环境下从堆空间中划分内存空间是线程不安全的;

- 一般为了避免多个线程操作同一地址, 需要使用加锁机制, 但是会影响分配速度; TLAB就是为了解决这个问题。

> 所以`TLAB`的目的是为了解决多线程环境下, 对象分配内存的线程安全问题

从内存模型的角度, `TLAB`是存在于Eden区中划分的, JVM为每个线程分配了私有缓存区域; **当多线程同时分配内存时,使用`TLAB`可以避免一系列的非线程安全问题, 同时还能够提升内存分配的吞吐量, 又称为快速分配策略。**

所有从OpenJDK衍生出来的JVM都提供了TLAB的设计。

**`TLAB`说明:**

1. JVM明确是将TLAB作为内存分配的首选, 但是不是所有对象实例都能够在TLAB中成功分配内存;

2. 可以通过`-XX:+UseTLAB`设置开启TLAB空间;

3. 默认情况下, TLAB空间呢村非常小, 仅占整个Eden空间的1%, 我们可以通过`-XX:TLABWasteTargetPercent`设置TLAB空间比例大小;

4. 一旦对象在TLAB空间分配内存失败时, JVM就会尝试通过加锁机制确保数据操作的原子性, 直接在Eden区分配内存。

> 通过`jinfo -flag UseTLAB 进程id`, 如果输出`-XX:+UseTLAB`说明TLAB是开启的。(默认就是开启的)

通过加入了TLAB, 所以整个对象分配内存的过程如下:

![jvm_objectallocation](/image/jvm_objectallocation.png)
