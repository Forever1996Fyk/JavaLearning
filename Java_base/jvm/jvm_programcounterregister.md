## JVM运行时数据区--程序计数器

JVM中程序计数寄存器(`Program Counter Register`)中, Register的命令源于CPU的寄存器, 寄存器存储指令相关的信息。CPU只有把数据装载到寄存器才能够运行。

JVM中的PC寄存器(程序计数器)是对物理CPU寄存器的一种抽象模拟。

一个线程对应一个JVM Stack(虚拟机栈)。JVM Stack中包含一组栈帧(`Stack Frame`)。当JVM调用一个Java方法时, 它会从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小, 并据此分配栈帧内存, 然后压入JVM栈中。

在活动线程中, 只有位于栈顶的栈帧才是有效的, 称为**当前栈帧**。与这个栈帧相关联的方法称为当前方法。

![jvm_pcr1](/image/jvm_pcr1.png)

### 1. 程序计数器作用

**程序计数器是用来存储指向下一条指令的地址, 也就是将要执行的指令代码。**由执行引擎读取下一条指令。

- 它是很小的内存空间, 几乎可以忽略, 也是运行速度最快的存储区域;

- 每个线程都有自己的程序计数器, 线程私有的, 生命周期与线程的生命周期保持一致。

- 任何时间一个线程都只有一个方法在执行, 也就是上面说的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址; 或者如果执行native方法, 则是undefined, **因为程序计数器不负责本地方法栈。**

- 程序计数器中没有规定OOM的情况, 也没有垃圾回收。

![jvm_pcr2](/image/jvm_pcr2.png)

### 2. 程序计数面试常问

1. 使用程序计数器存储指令地址有什么用?

- 多线程宏观上是并行(多个程序在同一时刻同时发生)的, 但实际上是并发交替执行的;
- 因为CPU需要不停地切换各个线程, 当切换线程时, 就需要知道应该从哪里开始继续执行。

2. 程序计数器为什么要设定为线程私有的?

- **我们知道多线程在任何时间只会执行一个指令, 通过CPU不停的轮转, 为了能够准确的记录各个线程正在执行的当前指令地址, 最好的办法就是为每一个线程都分配一个程序计数器, 这样各个线程之间可以进行独立计算, 不会相互干扰。**

### 3. 并行与并发

![jvm_pcr3](/image/jvm_pcr3.jpg)

并发是两个队列交替使用一台咖啡机; 并行是两个队列同时使用两台咖啡机; 串行是一个队列使用一台咖啡机.

所以对于并行与并发对简单的解释就是:

- **并行是多个线程同时被多个CPU执行**

- **并发是多个线程被一个CPU轮流切换执行(宏观上看起来是同时执行, 但实际上是时间片轮转的方式任何时间只会有一个线程执行)**
