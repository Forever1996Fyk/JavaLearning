## JVM堆--堆是分配对象的唯一选择吗?

在JVM中, 一般情况下, 对象都是在堆中分配内存的。但是有一种特殊情况, 那就是**逃逸分析(`Escape Analysis`)。**

> **如果一个对象并没有逃逸出方法的话, 那么就可能被优化成栈上分配。** 这样就不需要堆上分配内存, 也不需要进行垃圾回收了。

### 1. 逃逸分析

如何将堆上的对象分配到栈, 就需要使用逃逸分析手段。

通过逃逸分析, Java Hotspot编译器能够分析出一个新的对象的引用适用范围从而决定是否要将这个对象分配到堆上。

**逃逸分析的基本行为就是分析对象动态作用域:**

- 当一个对象在方法中被定义后, 对象只会在方法内部使用, 则认为没有发生逃逸;

- 当一个对象在方法中被定义后, 它被外部方法所引用, 则认为发生逃逸。

> 如果快速判断是否发生了逃逸, 就看new的对象实体是否有可能在方法外被调用。

例如下面代码:

```java
public void method() {
    V v  = new V();

    //...

    v = null;
}
```

我们可以看到V对象的作用域只存在于方法内部, 没有其他外部方法引用, 所以V对象实例是可以分配到栈上。

- 随着方法执行的结束, 栈空间就被移除;

- 虚拟机栈空间是线程私有的, 不会被共享。

在JDK6之后, HotSpot默认开启逃逸分析:

- `-XX:DoEscapeAnalysis`: 显式开启逃逸分析;

- `-XX:+PrintEscapeAnalysis`: 查看逃逸分析的筛选结果。

### 2. 代码优化理论

利用逃逸分析, 编译器可以对象代码机械能优化:

1. 栈上分配: 将对分配转化为栈分配。如果一个对象在线程中被分配, 而且这个对象的指针永远不会逃逸(也就是不会有外部方法调用), 对象可能是栈分配, 而不是堆分配;

2. 同步省略: 如果一个对象只能被一个线程访问, 那么对于这个对象的操作可以不考虑同步操作;

3. 分离对象或标量替换: 有的对象可能不需要作为一个连续的内存结构, 那么对象的部分(或全部)可以不存储在堆内存中, 而是存储在CPU寄存器。


对于同步省略优化, 其实比较好理解, 我们先看下面一段代码:

```java
/**
 * 同步省略说明
 */
public class SynchronizedTest {
    public void f() {
        Object hollis = new Object();
        synchronized(hollis) {
            System.out.println(hollis);
        }
    }
    //代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f（）方法中
    //并不会被其他线程所访问控制，所以在JIT编译阶段就会被优化掉。
    //优化为 ↓
    public void f2() {
        Object hollis = new Object();
        System.out.println(hollis);
    }
}
```

上面的f()方法虽然代码是存在问题的, 但是是可以解释同步省略的。

#### 2.1 标量替换

- 标量`Scalar`: 是指一个无法在分解成更小的数据的数据。JAVA中原始的数据类型就是标量;

- 与标量相对的就是聚合量(`Aggregate`), Java中对象就是聚合量, 因为它可以分解成其他聚合量和标量;

> 在JIT阶段, 如果经过逃逸分析, 发现一个对象不会被外界访问的话, 那么经过JIT优化, 就会把这个对象拆解成若干个成员变量来替代。这个过程就是标量替换。

我们通过`-XX:+EliminateAllocations`开启变量替换, 例如下面代码:

```java
public class ScalarTest {
    public static void main(String[] args) {
        alloc();   
    }
    public static void alloc(){
        Point point = new Point(1,2);
    }
}
class Point{
    private int x;
    private int y;
    public Point(int x,int y){
        this.x = x;
        this.y = y;
    }
}
```

经过标量替换后就会变成:

```java
public static void alloc(){
    int x = 1;
    int y = 2;
}
```

我们从上面的代码, 再结合栈上分配可以得到: **其实Java Hotspot没有是真正的实现栈上分配, 只是利用标量替换方式把对象分配优化到CPU寄存器上了, 大大减少了堆内存的占用。**


### 3. 总结

虽然上面一直在说明**逃逸分析**, 而且这项技术早就提出来了。但是这项技术到如今也并不是很成熟。

**根本原因就是无法保证逃逸分析的性能销毁一定会比堆分配的性能要好。**

> 例如, 经过逃逸分析之后, 发现所有的对象都是逃逸的, 那就白白浪费了逃逸分析的过程, 甚至更耗性能了。

**所以到目前为止, 我们都认为堆就是分配对象的唯一选择。但是标量替换的存在还是实现了栈上分配的思想, 减少了堆空间的占用。**