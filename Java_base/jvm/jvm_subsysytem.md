## JVM 类加载子系统

对于这块的知识, 我们简单的说明, 主要是对JVM加载系统整体框架的认识。后面每个模块还会详细说明。

先看下面的JVM细节版架构图:

![jvm_subsystem1](/image/jvm_subsystem1.png)

### 1. 类加载子系统的作用

1. 类加载子系统负责从文件或者网络中加载class文件, class文件的16进制开头有特定的文件标识即 **CA FE BA BE**。

2. 加载后的Class类信息存放在**方法区**的内存空间, 方法区还会存放运行时常量池信息。

![jvm_subsystem2](/image/jvm_subsystem2.png)

对于上面要注意的是:

**`ClassLoader`只负责class文件的加载, 至于这个class是否可以运行, 是有执行引擎`Execution Engine`决定的。**

并且如果调用构造器实例化对象, 其实例存放在堆内存中。

### 2. 类加载子系统功能细分

![jvm_subsystem3](/image/jvm_subsystem3.png)

#### 2.1 加载 Loading

1. 通过类的全限定名获取定义此类的二进制字节流;

2. 将这个类的字节流所代表的的静态存储结构转化为方法区的运行时数据;

3. 在内存中生成一个代表这个类的`java.lang.Class`对象, 作为这个类的各种数据的访问入口。

#### 2.2 链接 Linking: 验证, 准备, 解析

**验证:**

1. 确保Class文件的字节流的信息符合虚拟机的要求, 保证被加载类的正确性, 不会危害到JVM自身;

2. 主要包含四种验证: 文件格式验证, 元数据验证, 字节码验证, 符号引用验证。

**准备:**

1. 为类变量分配内存并设置该类变量的默认初始值, 即零值;

2. 被final修饰的static常量, 在编译阶段就已经分配了内存, 在准备节点会显示初始化;

3. 实例变量不会初始化, 会随着对象分配到java堆内存。

**解析:**

1. 将常量池的符号引用转换为直接引用;

2. 解析动作主要针对类, 接口, 字段, 类方法, 接口方法, 方法类型等。

#### 2.3 初始化 initialization

初始化阶段就是执行类构造器方法`clinit()`的过程。

**注意这个方法, 此方法不需要定义, 是javac编译器自动提供的。**

> javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。

只有当前类存在静态结构时才会使用, 包括, static变量, static代码块。

而且**构造器方法`clinit()`中指令按语句在源文件中出现的顺序执行。**

```java
public class ClinitTest {
    static {
        num = 20;
    }

    private static int num = 10;

    public static void main(String[] args) {
        System.out.println(ClinitTest.num);
    }
}
```

上面代码中, 打印出结果是 10。

>我们根据上面的类加载流程可以知道, 在链接linking的准备(Preparation)阶段, 就已经为类的静态变量默认分配内存了, 并且默认初始值为零值, (这里定义的变量是int, 所以默认为0; 如果是String, 则默认null)。然后在执行初始化阶段开始按照代码顺序赋值。

所以num变量的值变化过程为:

1. 准备阶段: num = 0;

2. 初始化阶段: num = 20 ---> num = 10;


**虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。即一个类只需要被clinit一次。**