## JVM -- G1垃圾收集器

之前我们学习的`Serail`, `ParNew`, `CMS`, `Parallel`收集器都是基于分代模型, 而G1是不分代收集器(只是逻辑上分代)。

> G1的目标是在低延迟的情况下, 尽可能的提高吞吐量!!!

### 1. G1收集器简介

首先G1是并发与并行都存在的收集器, 它把堆内存早逻辑上分为多个不想管的区域(`Region`)(物理上不连续)。使用不同的`Region`标识Eden, S0, S1, 老年代, 以及超大对象区域。

G1的原理为: **G1通过这种逻辑分代, 很好的避免了在整个Java堆的垃圾收集。G1会跟踪每个`Region`中的垃圾价值大小(回收所获得的空间大小以及所需时间), 维护一个有序列表, 每一次根据允许的收集时间(这也是低延迟的体现), 优先回收价值最大的`Region`**

> 由于这种方式的侧重点在于回收垃圾最大量的`Region`, 所以叫G1, 垃圾优先(Garbage First)。

G1在JDK8中不是默认垃圾回收器, 需要使用`-XX:+UseG1GC`来启用

### 2. G1垃圾收集器优势

G1将内存划分为一个个的`Region`, 内存的回收也是以`Region`作为基本单位, 而`Region`之间用的是**复制算法**。

但是G1整体实际上可以看做是**标记压缩算法**, 但是这两种算法都可以避免内存碎片, 有利于程序长时间运行, 分配大对象时不会因为无法找到连续内存空间而提前触发GC。
所以当Java堆内存非常大时, G1的优势更加明显。

### 3. G1 参数设置

- `-XX:+UseG1GC`: 手动指定使用G1收集器;

- `-XX:G1HeapRegionSize`: 设置每个Region的大小, 值是2的n次幂, 范围是1M到32M之间, 根据最小的Java堆大小划分出大约2048个区域。默认是堆内存的1/2000。

- `-XX:MaxGCPauseMills`: 设置期望达到的最大GC停顿时间指标(JVM会尽力实现, 但不保证达到)。默认值是200ms。

- `-XX:ParallelGCThreads`: 设置垃圾回收线程数。最多设置为8。

- `-XX:ConcGCThreads`: 设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。

- `-XX:InitiatingHeapOccupancyPercent`: 设置老年代占整堆比阈值。超过该值, 就触发GC。默认值是45。

#### 3.1 G1回收器的常见操作

G1的设计原则就是简化JVM性能调优, 开发人员只需要简单的操作即可完成调优:

1. 开启G1垃圾收集器;

2. 设置堆的最大内存;

3. 设置最大的停顿时间

G1中提供了三种垃圾回收模式: `YoungGC`, `Mixed GC`和`Full GC`, 它们分别在不同的条件下触发。

![jvm_g1](/image/jvm_g1.png)

### 4. Region

使用G1收集器时, 它将整个Java堆划分成大约2048个大小相同的独立Region块, 每个Region大小根据堆空间的实际大小而定, 整体被控制在1MB到32MB之间, 且为2的n次幂, 即1MB, 2MB, 4MB, 8MB...32MB。

也可以通过`-XX:G1HeapRegionSize`设定Region的大小; **要注意的是, 在JVM生命周期内是不会改变的**。

G1利用Region实现逻辑上的分代区域:

![jvm_g1_1](/image/jvm_g1_1.png)

G1垃圾收集器增加了一种新的内存区域`Humongous`。主要用于存储大对象, 如果对象超过0.5个Region, 就放到H区。

> **设置H区的原因:** 对于堆中的大对象, 默认直接会被分配到老年代, 但是如果它是一个**短期存在的大对象**, 放入老年代可能不容易回收。所以G1划分了`Humongous`区, 专门存放大对象。如果H区装不下大对象, 那么G1会寻找连续的H区存储。

### 5. G1收集器垃圾回收过程

G1垃圾回收过程主要包括三个环节:

- 年轻代GC(Young GC)

- 老年代并发标记过程(Concurrent Marking)

- 混合回收(Mixed GC)

- 如果G1垃圾回收失败, 会提供失败保护机制, 还是会使用单线程, 独占式的Full GC来强力回收。

1. 应用程序分配内存, 当年轻代Eden区用完时开始年轻代回收过程;

    > G1的年轻代收集过程是并行的, 所以会STW。G1 GC会暂停所有用户程序, 启动多个线程执行年轻代回收, 将Eden去对象移动到Survivor或者old区。

2. 当老年代内存使用率到达阈值时(默认是45%), 开始老年代并发标记过程;

3. 老年代标记完成, 马上开始混合回收过程。所谓混合回收就是年轻代和老年代是一起被回收的。

#### 5.1 记忆集合与写屏障

**写屏障**在CMS处理错标对象的问题中也用到了, 就是在对象建立引用的过程记录下来。记录到哪呢? 就是**记忆集合(`Remember Set`)**, 简称RS。

**利用记忆集合与写屏障是为了解决不同Region之间的引用问题。**

> 一个Region虽然是独立存在的, 但是不可能孤立的。因为一个Region中的对象可能被其他任意的Region中对象引用, 那么在判断对象是否存在引用时, 如果扫描整个堆空间效率非常低; 所以存在记忆集合, 用来记录每个对象的引用关系。

- 无论是G1还是其他分代收集器, JVM都是使用`Remember Set`来避免全局扫描;

- 每个`Region`都有一个对应的RS;

- 每次对象建立引用时, 都会产生一个写屏障(`write barrier`)暂时中断操作; 将引用记录到记忆集合中;

- 然后检查将要指向的对象是否是在同一个Region中; 如果不在就通过一个CardTable把相关信息记录到引用指向对象所在的Region中的RS中;

- 当进行垃圾回收时, 在GC根节点加入RS, 就可以保证不进行全局扫描, 也不会有遗漏。

![jvm_g1_2](/image/jvm_g1_2.png)

### 6 G1回收过程详解

G1回收的过程十分复杂, 虽然被分为三个环节, 每个环节都存在大量的细节。

#### 6.1 年轻代GC(Young GC)

1. 程序在运行过程中不断创建对象到Eden区, 当Eden区空间耗尽时, G1会启动一次年轻代垃圾回收过程;

    > 年轻代垃圾回收只会回收Eden区和Survivor区

2. YGC时, 首先暂停用户线程STW, G1创建回收集(`Collection Set`);

    > 回收集是指需要被回收的内存`Region`分段集合, 年轻代回收过程的回收集包含Eden区和Survivor区。

3. 然后扫描存活对象, **根引用连同RS记录的外部引用作为扫描存活对象的入口。**

4. 更新`Remember Set`, 处理`dirty card queue`中的card;

    > - `dirty card queue`: 对于应用程序的引用赋值语句`object.field=object`, JVM会在之前和之后执行特殊的操作以在队列中保存对象的引用信息;
    > - 在年轻代回收时, G1会处理`dirty card queue`中所有的对象引用信息, 来更新RS, 保证RS实时准确的反映引用关系;
    > - 为什么不直接更新RS? 因为提高性能, RS处理需要线程同步, 所以使用队列实现异步更新。

5. 处理`Remeber Set`, 识别老年代对象指向Eden中的对象, 也就是存活对象;

6. 复制对象, 对象引用链遍历, Eden去中存活对象被复制到Survivor区, Survivor区中存活对象的分代年龄加1, 如果分代年龄达到阈值(默认15), 那么对象就会被复制到Old区;

7. 处理引用, 主要是处理 软, 弱, 虚引用。最终Eden区会清空, 而且存活对象都是连续的, 没有碎片。

#### 6.2 并发标记过程

1. **初始标记阶段: 标记根节点直接引用的对象**。这个过程是STW的, 而且会触发一次YGC;

2. 根区域扫描(`Root Region Scanning`): G1扫描Survivor区直接引用老年代区域的对象, 并标记被引用的对象; **这一过程必须要在YGC之前完成**;

3. 并发标记(`Concurrent Marking`): 整个堆进行并发标记, 同时计算每个区域的存回对象的比例;

4. 重新标记(`Remark`): 修正并发标记的结果, 也是STW的。G1采用的是SATB算法(`snapshot-at-the-beginning`);

    > 由于上一步的并发标记过程, 用户线程仍在执行, 所以很有可能产生了新的存活对象; 也就是用户线程把原来的垃圾对象, 建立了新的引用

5. 独占清除: 计算各个区域存活对象和GC回收比例, 并进行排序以及识别可以混合回收的区域, 该阶段也是STW的;

    > 独占清除阶段并不会真正的开始清除垃圾, 而且为清除垃圾做准备

6. 并发清除: 并发清除垃圾对象。

#### 6.3 混合回收

当越来越多的对象晋升老年代Old Region时, 为了避免堆内存被耗尽, JVM会触发一次混合回收, 即Mixed GC。它不仅会回收整个 年轻代Region, 还会**回收一部分Old Region**, 从而控制垃圾回收的耗时时间。

- 并发标记之后, 老年代百分百为垃圾的内存Region会被回收, 部分垃圾的Region被计算出来。默认情况下, 老年代的内存Region会分8次回收。(可以通过`-XX:G1MixedGCCountTarget`设置次数);

- 混合回收的算法与年轻代回收算法完全一样, 只是回收集(`Collection Set`)多了老年代的内存Region;

- G1会优先回收垃圾多的内存Region, 垃圾占内存Region比例越高的, 则先回收。`-XX:G1MixedGCLiveThresholdPercent`表示内存Region是否被回收的阈值。默认是65%, 也就是说垃圾占Region比例达到65%才会被回收, 如果占比太低, 意味着存活的对象较多, 使用**复制算法**是会花费更多的时间;

- 混合回收并不一定要进行8次。`-XX:G1HeapWastePercent`设置阈值, 默认10%。允许整个堆内存中有10%的空间被浪费, 也就是说如果发现可以回收的垃圾占堆内存的比例低于10%, 则不再进行混合回收。因为GC会花费很多的时间但回收的内存却很少。

#### 6.4 Full GC

G1的初衷就是要避免Full GC的出现。但是如果上面的过程不能正常执行, G1会暂停用户线程, 使用单线程进行垃圾回收, 性能非常差, 应用程序停顿时间很长。

出现G1 Full GC的原因可能有两个:

1. 回收阶段没有足够的to - space来存放晋升的对象;

2. 并发处理过程之间空间耗尽了。

### 7. G1收集器优化建议

- **年轻代大小**

避免使用`-Xmn` 或 `-XX:NewRatio`等相关选项显式设置年轻代大小, 因为固定的年轻代大小会覆盖低延迟的目的。

- **对低延迟的目标不要太过苛刻**

G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间.

评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表 示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。