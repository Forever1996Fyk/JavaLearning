## JVM--对象实例化内存布局与访问定位

### 1. 创建对象的方式

1. new: 最常见的方式, 但是本质上是构造器

    - 变形1: Xxx的静态方法
    - 变形2: XxxBuilder/XxxFactory的静态方法


2. Class的newInstance(): 反射的方式, 只能调用空参的构造器, 权限必须是public

3. Constructor的newInstance(Xxx): 反射的方式, 位于`java.lang.reflect.Constructor<T>`可以调用空参, 带参的构造器, 权限没有要求;

4. 使用clone(): 不调用任何构造器, 当前类需要实现Cloneable接口, 实现clone();

5. 使用反序列化: 从文件中, 网络中获取一个对象的二进制流;

6. 第三方库Objenesis

### 2. 创建对象的步骤

1. **判断对象对应的类是否加载, 链接, 初始化**

    - 虚拟机遇到一条new指令, 首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用, 并且检查这个符号引用代表的类是否已经被加载, 解析和初始化。(也就是判断元空间中是否存在类的信息);
    
    - 如果元空间没有对应类的信息, 那么利用双亲委派模式, 使用当前类加载器以`ClassLoader+包名+类名`为Key进行查找对应的.class文件;
    
    - 如果没有找到class文件, 则抛出`ClassNotFountExecption`异常;
    
    - 如果找到则进行类加载, 并生成对应的Class类对象。

2. **为对象分配内存**

    首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

3. **处理并发安全问题**

    在分配内存空间时, 还有一个重要的问题就是保证new对象过程的线程安全性。创建对象是非常频繁的操作, 虚拟机需要解决并发问题。

    - `CAS(Compare And Swap)`: 保证指针更新操作的原子性;

    - `TLAB`: 把内存分配的动作按照线程划分在不同的空间中进行, 即每个线程在Java堆中预先分配一小块内存, 称为本地线程分配缓冲区(TLAB, Thread Local Allocation Buffer)。

4. **初始化对象属性**

    Java给对象的属性赋值操作有4种:

        - 属性的默认初始化; (也就是所有属性设置默认值, 保证对象实例字段不赋值也可以直接使用)

        - 显示初始化;

        - 代码块初始化;

        - 构造器初始化。

    内存分配结束, 虚拟机将分配到内存空间都初始化为零值。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

    > 如果是基本类型字段就是默认初始值, 例如int默认是0; 如果是引用字段就默认为null。

5. **设置对象的对象头**

    将对象的所属类(即类的元数据信息), 对象的HashCode和对象的GC信息, 锁信息等数据存储在对象头中。

6. **执行init方法进行初始化**

    当前5步都完成了, 在Java程序角度来看, 对象初始化才正式开始。

    - 初始化成员变量

    - 执行实例化代码块

    - 调用类的构造方法

    - 把堆内对象的地址赋值给引用变量

### 3. 对象内存布局

对象在堆中的结构主要数三部分组成:

1. 对象头(Header): 包含两部分, `MarkWord`, 类型指针;

2. 实例数据(Instance Data)

    它是对象真正存储的有效信息, 包括定义的各种类型字段(包括从父类继承的字段), 规则为:

    - 相同宽度的字段总被分配在一起;

    - 父类中定义的变量会出现在子类之前;

    - 如果`CompactFields`参数为true, 子类的窄变量可能插入到父类变量的空隙。

3. 对齐填充(Padding)

    这部分并不是一定存在的, 也没有特别的含义, 它仅仅起着占位符的作用。因为HotSpot Vm要求对象的大小必须是8的整数倍。
    而对象头正好是8字节倍数, 因此当对象实例数据部分没有对齐, 就需要通过padding部分来补全。

#### 3.1 MarkWord

这是对象很重要的部分, 用户存储对象自身运行时的数据, 所以又称为运行时元数据。具体存储内容如下:

- 哈希值(HashCode)

- GC分代年龄

- 锁状态标志

- 线程持有锁

- 偏向线程ID

- 偏向时间戳

这部分存储的数据其实很多, 已经超过了32,64位Bitmap结构所能记录的限制, 考虑到虚拟机的空间效率。**`Mark Word`被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息。**

> 例如在32位HotSpot虚拟机中对象未被锁定的状态下, `Mark Word`的32位空间中, 25bit用于存储对象哈希码(HashCode), 4bit用于存储对象分代年龄, 2bit存储锁标志位, 1bit固定为0。

这里的锁标志, 还涉及到锁状态升级过程! 可以看这篇文章[深入Synchronized](/java_base/concurrent/base/thread_synchronized_deep.md)

#### 3.2 类型指针

**类型指针**是对象指向它的类的元数据的指针`InstanceKlass`, 确定该对象所属的类型。但是并不是所有的虚拟机实现都必须在对象数据上保留类型指针, 也就是说查找对象的元数据信息并不一定要经过对象本身。

如果对象是一个Java数组, 那么对象头中还必须有一块记录数组长度的数据,虚拟机可能通过Java对象的元数据确定Java对象的大小, 但是从数组的元数据中无法确定数组的大小。

> 类型指针就是指向元数据区类信息

#### 3.3 JVM运行时数据区详细关系图

我们看下简单的示例代码:

```java
public class CustomerDemo {
    public static void main(String[] args) {
        Customer customer = new Customer();
    }
}

public class Customer {
    private String id = "1001";
    private String name;
    private Account acct;
}

public class Account {

}
```

上面的代码在JVM运行时数据区的关联图:

![jvm_objectlayout1](/image/jvm_objectlayout1.png)

### 4. 对象访问定位

创建对象的目的就是为了使用对象。Java程序中需要通过栈上的`reference`数据来操作堆上的具体对象。

对象的访问方式主要有两种: **句柄访问**, **直接指针**。 HotSport VM使用的就是直接指针的方式。

![jvm_objectlayout2](/image/jvm_objectlayout2.png)

#### 4.1 句柄访问

Java堆中会划分一块内存作为句柄池, `reference`中存储的就是对象的句柄地址, 而句柄池包含了指向对象实例数据的指针,以及指向对象元数据(类型数据)的指针。

![jvm_objectlayout3](/image/jvm_objectlayout3.png)

句柄定位方式优缺点:

- 缺点: 占用空间, 间接指向对象实例;

- 优点: 定位稳定, 当对象实例发生移动(垃圾回收, 内存整理), 则不需要修改`reference`中的句柄地址, 只需要在句柄内修改间接地址, 重新定位到对象实例即可。

#### 4.2 直接指针

直接指针访问, Java堆中的对象布局中就必须考虑如何放置类型数据的相关信息, 因为需要指向方法区中的对象类型信息。 `reference`存储的直接就是对象的地址。

![jvm_objectlayout4](/image/jvm_objectlayout4.png)




