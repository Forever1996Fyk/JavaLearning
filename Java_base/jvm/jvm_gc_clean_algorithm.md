## JVM垃圾回收清除算法

当Java通过**可达性分析算法(Root Searching)**之后, 成功的区分出内存中存活对象和垃圾时, GC就开始执行垃圾回收, 释放掉垃圾对象所占用的内存空间, 以便有足够的可用内存空间为新对象分配内存。


目前在JVM中比较常见的三种垃圾算法:

- 标记-清除算法(Mark-Sweep)

- 复制算法(Copying)

- 标记-压缩算法(Mark-Compact)

### 1. 标记-清除算法(Mark-Sweep)

**标记清除算法(`Mark-Sweep`)**是一种基础和常见的垃圾收集算法。

当堆中的有效内存空间(`available memory`)被耗尽时, 就是暂停整个用户线程(Stop The World), 然后进行两项工作, 标记和清除。

- 标记: 通过可达性分析算法, 从引用根节点开始遍历, 标记所有被引用的对象。**一般在对象的对象头中记录为可达对象。**

- 清除: 垃圾回收器对堆内存从头到尾进行线性的遍历, 如果发现某个对象没有标记, 则将其回收。

![jvm_mark_clean1](/image/jvm_mark_clean1.png)

通过上面的图, 我们也会发现标记清除算法的缺点:

1. 效率不算高; 需要进行两次遍历: 第一次遍历标记, 第二次遍历清除;

2. 在进行GC时, 需要停止整个应用程序;

3. **标记清除过后, 空闲的内存是不连续的, 产生内存碎片。需要维护一个空闲列表。**

**要注意, 清除的意思?**

> 这里的清除并不是直接把内存置空, 而是把需要清除的对象地址保存在一个空闲列表中。下次有新对象需要加载时, 判断垃圾的位置空闲是否够, 如果够就存放。

### 2. 复制算法(Copying)

**复制算法**的核心思想是将存活的内存空闲分为两块, 每次只是用其中一块, 在垃圾回收时将正在使用的内存中的存活对象复制到未使用的内存块中, 之后清除正在使用内存块中的所有对象。最后在互换两块内存的角色。

**年轻代的S0和S1使用的就是复制算法**

![jvm_mark_clean2](/image/jvm_copying1.png)

我们可以看到, 每次复制过后, 被复制的内存就会被清空, 而将存活对象存入另一块内存。

**复制算法的优点:**

- 很明显没有标记和清除的遍历过程, 速度更快, 效率更高;

- 复制后保证了空闲内存的连续性, 不会出现内存碎片。

同样的**复制算法的缺点**也很明显:

- 需要两倍的内存空间, 才能满足复制的需求。

对比**标记清除算法**, 复制算法的时间复杂度小, 但是需要的空间复杂度更高。如果垃圾对象很多, 复制算法需要复制的存活对象就会少, 效率就很高。但是反之, 垃圾对象很少或者都是存活对象, 那么消耗的时间也不少, 而且由于复制的原因, 导致内存折半。

**应用场景:**

在前面学习的Java堆的分代知识时, 我们知道年轻代存放的大部分都是朝生夕死的对象, 一次垃圾回收可能会回收70%-99%的内存空间。这完全符合**复制算法**的应用场景。所以又区分了S0和S1区来实现复制算法。

![jvm_copying2](/image/jvm_copying2.png)


### 3.标记-压缩/整理算法(Mark-Compact)

**复制算法**的高效性是建立在存活对象少, 垃圾多的前提下。而这种情况经常发生在年轻代。但是在老年代, 更常见的是大部分对象都是存活对象, 如果依然使用复制算法, 由于存活对象较多, 而且老年代的空间一般较大, 所以复制成本就很高。(不仅效率低, 而且所需的空间更多)

而**标记清除算法**虽然可以用在老年代, 但是由于这种算法不仅效率低下, 而且会产生内存碎片。

所以综上考虑使用**标记压缩/整理算法**。

**标记压缩算法的过程:**

1. 第一阶段与**标记清除算法**一样, 从根节点开始标记所有被引用对象;

2. 第二阶段将所有的存活对象压缩到内存的一端, 按顺序排放;

3. 最后清除边界外的所有空间。(注意这里的清除, 是直接将内存置空)

![jvm_mark_compact1](/image/jvm_mark_compact1.png)

**标记-压缩算法**的最终效果等同于**标记-清除算法**执行结束后, 在进行一次内存碎片整理。

整理完成后, JVM会维护一个指向**空闲内存的起始地址**,因为此时已用的内存都是有序的, 所以当新对象分配时, 只需要从这个起始地址开始判断空间是否足够即可。也成为了指针碰撞。

> **指针碰撞(`Bump the Pointer`):** 如果内存空间是规整和有序的方式分布, 即已用和未用的内存都区分开来, 彼此之间维护这下一次分配起始点的标记指针。 当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞(Bump the Pointer)。


**标记压缩算法的优点:**

- 不会存在内存碎片;

- 给新对象分配内存时,JVM只需要维护一个内存的起始地址即可。不需要维护空闲列表记录垃圾的内存地址

- 也不存在**复制算法**的内存减半问题。

**标记压缩算法的缺点:**

- 效率比**标记清除算法**还要低, 因为不仅需要遍历, 还需要整理内存碎片;

- 在移动对象的同时, 导致了内存地址的变化, 如果该对象被其他对象引用, 则还需要调整引用的地址。

### 4. 总结

从上面3中算法来看, 没有最优的算法, 只有更合适的算法。

![jvm_gc_clean_algorithm1](/image/jvm_gc_clean_algorithm1.png)

于是就出现了 **分代收集算法**。

JVM根据对象生命周期的长短, 将堆区分为年轻代和老年代, 这样就可以根据各个年代的特点使用不同的回收算法, 以提高垃圾回收的效率。





