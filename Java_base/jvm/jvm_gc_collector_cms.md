## JVM -- CMS垃圾回收器(低延迟)

CMS全称`Concurreny Mark Sweep`, 是基于并发的垃圾收集器,实现了垃圾收集线程与用户线程同时工作。

CMS收集器的关注点在尽可能缩短垃圾收集时用户线程的停顿时间。所以比较适合频繁与用户交互的程序, 提升用户体验。

CMS收集器采用**标记清除算法**, 而且也会发生STW。

> CMS的问题很多, 所以没有任何一个版本的JVM把CMS作为一款默认的垃圾收集器。CMS其实是一个承上启下的垃圾收集器, 承上: 就是解决了之前垃圾收集器的STW高延迟问题; 启下: 就是开启了并发垃圾收集器的新模式。之后的G1, ZGC等都是在CMS的基础上不断的优化改良。

### 1. CMS执行过程

CMS整个过程非常复杂。整个过程其实分为7个阶段, 但是一般重点在于其4个阶段: **初始标记, 并发标记, 重新标记, 并发清理。**

![jvm_cms1](/image/jvm_cms1.png)

1. **初始标记(`Initial-Mark`):** 这个阶段主要仅仅是**标记出GCRoots直接关联到的对象**; 所以该阶段是STW的。但是由于这个阶段只是标记直接关联对象, 所以速度很快, STW的事件非常短;

2. **并发标记(`Concurrent-Mark`):** 从第一阶段的标记直接关联对象开始遍历整个对象引用链, 并对引用对象进行标记; 该阶段是并发进行的, 也就是与用户线程并发运行;

3. **重新标记(`Remark`):** 由于在**并发标记**阶段, 用户线程与GC线程同时或者交叉运行, 所以有可能导致标记的对象产生变动, 也就是产生了新的对象(这里的新对象指的是引用指向对象); 需要修正并发标记的结果, 所以该阶段也是STW的;

4. **并发清理(`Concurrent Sweep`):** 该阶段也是并发的清除之前标记阶段的垃圾对象, 释放内存。

### 2. CMS分析

1. 从上面的4个阶段分析可以知道, 由于并发标记和并发清理的存在, 整CMS回收阶段的STW时间是很低的。

2. 另外, **由于CMS处理是并发的, 用户线程没有中断, 所以在CMS回收过程中, 必须要确保用户线程有足够的内存可用。因此, CMS收集器不能等到老年代没有空间存储对象时再去执行, 而是当堆内存使用率达到某一阈值时, 就开始回收。**

3. 如果CMS执行期间预留的内存无法满足用户线程的需要, 就会出现一次"`Concurrent Mode Failure`"失败, 此时虚拟机就启动备用方案: **临时启动`Serial Old`收集器来重新进行老年代的垃圾回收, 那这样STW的时间就很长了。**

4. CMS收集器采用的算法是**标记清除算法**, 这意味着每次执行后, 就会产生内存碎片问题; 所以为新对象分配内存时, 无法使用指针碰撞(Bump the Pointer)技术, 只能选择空闲列表(Free List)执行内存分配。

> 为什么CMS不用`Mark Compact标记压缩算法`呢?

因为当并发清除阶段时, 用户线程仍在执行, 此时如果整理内存碎片, 用户线程就无法使用内存。

### 3. CMS优缺点

CMS的优点:

- 并发收集

- 低延迟

CMS的弊端:

- 并发清理产生内存碎片, 导致用户线程可用的空间不足(因为可能需要连续的内存空间, 比如数组; 或者分配大对象); 需要提前进行Full GC;

- CMS依赖CPU资源, 在并发阶段虽然不会导致用户停顿, 但是会因为占用一部分线程而导致应用程序变慢, 总吞吐量降低;

- CMS无法处理**浮动垃圾**。可能会出现`Concurrent Mode Failure`, 导致使用`Serial Old`收集器, STW时间更长;

    > **浮动垃圾**就是在并发标记阶段, 如果产生新的垃圾对象, CMS无法对新的垃圾进行标记, 也就无法回收, 只能等下一次GC时释放。

> 这里可能会有问题, 既然在重新标记阶段, 已经进行修正了, 为什么还会出现浮动垃圾?

**重新标记**的对已标记的对象进行检测, 因为可能之前的垃圾对象又被其他对象引用了, 为了防止漏标, 就需要重新标记, 防止被当成垃圾清除了。(**这里要注意的, 标记的一直都是存活对象, 只有没有标记的对象才是垃圾。**)

而**浮动垃圾**是在并发标记阶段过程中被标记了, 但是在并发标记结束后可能变成了垃圾, 也就是产生了新的垃圾。

### 4. CMS参数设置

- `-XX:+UseConcMarkSweepGC` 手动指定使用CMS收集器执行内存回收;

    - 开启该参数后会自动将`-XX:+UseParNewGC`打开, 也就是**ParNew + CMS + Serail Old**组合。

- **`-XX:CMSInitiatingOccupanyFraction`**设置堆内存使用率的阈值, 一旦达到该阈值, 就开始进行CMS回收;

    - JDK5及以前的版本默认是68, 也就是当老年代的空间使用率达到68%时, 就会执行一次CMS。JDK6之后默认是92.

    > 如果内存增长缓慢, 则可以设置一个较大的值, 阈值较大, 可能降低CMS触发的频率; 烦着如果内存使用率增长较快, 则应该降低这个值, 以避免频繁的触发`Serial Old`收集器。**因此这个参数可以有效的降低Full GC的次数。**

- `-XX:+UseCMSCompactAtFullCollection`用于指定在执行完Full GC后对内存空间进行压缩整理, 以此避免产生内存碎片。**但是通过上面的扥西可以知道, 压缩整理过程是STW的。所以整理停顿时间更长了。**

- `-XX:CMSFullGCBeforeCompaction`设置在执行多少次Full GC后对内存空间进行压缩整理。

- `-XX:ParallelCMSThreads`设置CMSDE线程数。

    > CMS默认启动线程数时(ParallelGCThread + 3)/4, `ParallelGCThreads`是年轻代收集器的线程数。如果CPU资源比较紧张, 再加上CMS并发执行的影响, 应用程序的性能在垃圾回收阶段会非常糟糕。

### 5. CMS中的算法

CMS采用的是**标记清除算法**, 那么到底是怎么标记的?

我们知道寻找存活对象的算法是**可达性分析算法**, 那么找到了存活的对象用什么方式标记呢?

**CMS采用的时三色标记法。**就是把GC中的对象划分为三种情况:

- 黑色: 自己完成标记, 它的fields(也就是它的所有直接引用对象)也全部完成标记; 此时对象不能被回收;

- 灰色: 自已完成标记, 但是它的fields没有完成标记;

- 白色: 没有标记的对象。一定会被回收。

![jvm_cms2](/image/jvm_cms2.png)


所以标记的过程如下:

1. 刚开始所有的对象都是白色, 没有被访问;

2. 将GC Roots直接关联的对象置为灰色;(初始标记);

3. 遍历灰色对象的所有引用, 灰色对象本身置为黑色, 其引用置为灰色;(并发标记)

4. 重复步骤3, 知道没有灰色对象为止(重新标记);

5. 并发清除阶段, 黑色对象存活, 白色对象回收。

> 上面的过程正确执行的前提是没有其他线程改变对象间的引用关系, 然而, 并发标记过程中, 用户线程仍在运行, 因此就会产生漏标和错标的情况。

#### 5.1 漏标

如果GC已经在遍历对象B, 而此时用户线程执行了`A.B=null`的操作,切断了A到B的引用

![jvm_cms3](/image/jvm_cms3.png)

本来执行了`A.B=null`之后, B, D, E都可以被回收了, 但是由于B已经变成灰色, 它仍然会被当做存活对象, 最终的结果就是本轮GC不会回收B, D, E, 留到下次GC时回收, 这也是产生**浮动垃圾**的原因。

> 但是这个问题可以通过写屏障来解决, 只要在A与B引用关系建立时加入写屏障, 当A到B的引用切断时,就会记录, 然后重新标记时再把B标成白色。

#### 5.2 错标

假设GC线程已经遍历到B了, 此时用户线程执行了下面的操作:

```java
B.D=null;// B到D的引用被切断
A.xx=D; // A到D的引用被建立
```

![jvm_cms4](/image/jvm_cms4.png)

此时GC线程继续工作, 由于B不再引用D, 虽然A引用了D, 但是因为A已经是黑色了, 重新标记是不会再遍历A对象, 所以D还是被标记成白色, 最后被当做垃圾回收了。

> 可以看到错标的结果比漏标严重的多, **浮动垃圾**可以下次GC清理, 而错标则是把不该回收的对象回收掉了, 那么会直接导致程序错误。

要注意的是, 错标只会在两种情况下才会发生:

1. 灰色对象指向白色对象的引用全部断开;

2. 黑色对象指向白色对象的引用被建立。

只要打破上面任意一个条件, 就可以解决错标问题。

#### 5.3 原始快照和增量更新

**原始快照:**

当灰色对象指向白色对象的引用被断开时, 就会将这条引用关系记录下来。当扫描结束后, 再从灰色对象开始继续扫描, 但是无论引用关系是否删除, 都会按照刚开始扫描时那一瞬间的对象引用链快照来扫描。

**增量更新:**

当黑色指向白色的引用被建立时, 就将这个新的引用关系记录下来, 等扫描结束后, 再以这些记录中的黑色对象重新扫描, 于是再把这些白色对象变为灰色。

#### 5.4 写屏障

> 这里的写屏障与并发编程中的写屏障不是一个东西。这里的写屏障可以理解为AOP。在属性赋值的前后加入一些处理。

CMS采用的方案就是: 写屏障+增量更新来实现的。

当黑色指向白色的引用被建立是, 通过写屏障来记录引用关系, 等扫描结束后, 再以引用关系的黑色对象重新扫描一次即可。

### 6. 总结

CMS为了让用户线程与GC线程一起工作, 回收的过程与算法都比之前的垃圾回收器要复杂的多。<font color='red'>根本的原因, 就是因为GC标记对象的同时, 用户线程还在修改对象的引用关系。因此CMS引入例如三色算法, 将对象标记为黑, 灰, 白三种颜色对象, 并通过[写屏障]将用线程修改的引用关系记录下来, 在**重新标记**阶段可以修正对象的引用。</font>