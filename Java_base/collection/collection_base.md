## 基础知识概述

对数据的操作, 基本上就是**增、 删、 改、 查、根据位置获取数据, 排序。**改和查可以理解为一致的操作, 因为要修改一条数据需要先找到它, 然后替换即可。

本篇文章就是从这些操作简要分析Java集合中使用广泛的数据结构。

### 数组

数组在内存中占据一段连续的内存(**该解释, 会与多线程开发中的伪共享问题有关**), 所有的数据在内存中连续排列。它的大小是固定的, 这一特性使得数组对于插入操作并不友好, 在`ArrayList`中会详细讲解。但数组对于位置的访问是很友好的, 因为它支持所谓的`RandomAccess`特性, 时间复杂度为**O(1)**。数组的数据顺序与插入顺序一致, 所以查询操作需要遍历, 其时间复杂度为**O(n)**。

> 所以数组最大的优势在于基于位置的访问, 在扩展性方面表现无力。

### 链表

链表是通过指针域表示数据与数据之间的位置关系, 所以链表在头部或尾部插入数据的复杂度为**O(1)**。但是链表不具备`RandomAccess`特性, 所以无法提供基于位置的访问。查询操作也必须从头到尾遍历, 复杂度为**O(n)**。

> 所以链表最大的优势在于插入, 而查询的表现很一般

有没有一种结构能够结合数组和链表的优点, 使得查询和插入都具有优秀的表现? 这就是散列表.

### 散列表

散列表就是**Hash Table**, 这种结构使用`key-value`形式存储数据, 我们经常使用的`HashMap`、`HashTable`就基于这种数据结构。

数组和链表在查询时表现一般的原因在于它们并不记得数据的位置, 所以只能用待查询的数据和存储的数据依次比对。<br/>
**散列表使用一种巧妙的方式在减少甚至避免这种依次比对, 它的原理是通过一个函数把任何的key转为int, 每次查找时只需要执行一个这个函数便可以迅速定位。**

> 散列表并不是完美的, 因为不会有一个函数, 能够保证所有的key转换结构都不同, 也就是会发生所谓的`哈希碰撞`, 而且它必须依赖于其他的数据结构。

### 二叉排序树

二叉排序树是解决查询问题的另一种方案, 如果数据在插入时是有序的, 在查询时就可以使用**二分法**。

> 二分法的原理很简单, 比如查找一个在0-100之间的数, 那么第一次判断就直接跟50比较, 直接可以排除一般的数据, 每次都按照这个规则就可以很快的获取这个数的位置。**二分法的时间复杂度为O(lg n)**。

树的结构对二分法有天然的支持。二叉排序树牺牲了一部分插入的时间, 但是提高了查询的速度。如果查询的操作重要性超过了插入, 我们就应该考虑这种结构。<br/>
二叉排序树也存在一些不平衡导致效率下降的问题, 所以有了**AVL树**, **红黑树**, 以及用于数据库索引的**B树, B+树**。

### 集合分析

Java集合类分为两大部分: `Collection`和`Map`。而`Collection`由主要有`List`、 `Queue`、`Set`三大模块组成。