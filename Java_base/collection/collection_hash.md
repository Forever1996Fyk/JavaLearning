## Java集合基础: 哈希表

之前了解了数组和链表, 我们知道, 无论是数组还是链表, 对数据的查询表现都比较无力。要想知道一个元素是否在数组或链表中, 只能从前向后挨个对比。

**这个问题的根源在于, 我们没有办法直接根据一个元素找到它存储的位置。**

哈希表就是解决查询问题的一种方案。

### 哈希表与Hash函数

**Hash函数**, 是建立key值和int值映射关系的函数。
也就是说Hash函数可以把任意Java对象, 映射成int数值。用这个int数值进行处理可以作为数组的下标, 并把这个Java对象存入数组中, 这就是哈希表。

**所以哈希表就是一个数组, 只是每次插入数据都必须经过Hash函数。**

![hashtable](/image/hashtable.png)

哈希表完全继承了数组的有点, 有显著的提高了查询的速度, 通过Hash函数可以使得查询速度达到了 **O(1)**。

> 查询方式也很简单了, 利用我想查询A元素是否存在哈希表中, 只要用过Hash函数处理A元素, 然后经过处理获取到数组的下标, 然后直接获取判断是否存在即可。

但是Hash表也是有缺陷的, 这个缺陷就是**哈希碰撞**。

### 哈希碰撞

Hash函数的作用, 就是把任何对象根据规则映射成一个int值。被转换的对象有无数中可能, 但是int值也是有限的, 最大也只能是`2^32`。

**那么必然会有不同的对象, 映射到相同的int值, 这就是哈希碰撞。** 发生碰撞时, 就要把不同的元素插入到相同的位置, 此时单纯的使用一维数组已经无法满足需求。

#### 解决哈希碰撞

要解决哈希碰撞的方案很多, 比如利用二维数组, 将碰撞的元素按顺序存储起来。(类似于**建立公共溢出区**)

![hashconflict](/image/hashconflict.png)

但是这种方式有很大的问题: 因为数组的大小是固定的, 所以第二维的数组长度都是一样的, 但是哈希碰撞是比较少发生的情况, 也就是说我们声明了一个很大的数组, 但是其中大部分都是空闲的, 浪费了大量的内存。

目前比较通用的方法就是使用**数组+链表**组合的方法。当出现哈希碰撞时, 在该位置的数据就通过链表的方式链接起来。

![hashconflict1](/image/hashconflict1.png)

这是当前比较理想的方式, 既继承了数组的优点, 又在碰撞时继承了链表的优点。

> 在JDK1.7及以前的版本中, `HashMap`的存储结构和上图一致, 在JDK1.8之后还加入红黑树的数据结构进行优化。

下面是4中解决哈希冲突的方式:

1. **开放定址法**: 当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

2. **再哈希法**: 这种方法是同时构造多个不同的哈希函数：Hi=RH1（key） i=1，2，…，k 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

3. **链地址法**: 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

4. **建立公共溢出区**: 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

### 哈希表的优缺点

其实**哈希表**只是一种优化存储的思想, 具体存储元素的依然是其他的数据结构。

设计良好的哈希表, 能同时具备数组和链表的优点, 它能在插入和查找时都具备良好的性能。

设计不好的哈希表, 有可能会出现较多的哈希碰撞, 导致链表过长, 从而哈希表会更像一个链表。而且当数据量很大时, 为了防止链表过长, 就需要对数组进行扩容, 这是就涉及到数组的拷贝, 对性能的影响也很严重。