## Java集合基础: 二叉排序树

解决查询速度慢的方案除了哈希表外, 还可以使用二叉排序树。我们知道, 查询满主要是因为不知道元素的位置, 使用Hash函数映射虽然解决了问题, 但是并不稳定, 当出现大量的哈希碰撞后哈希表的表现更像一个链表, 查询速度降低。

二叉排序树的方案, 则是使元素有序, 这样便可以使用二分法进行查找了, 虽然效率相比hash函数低一些, 但是可以通过**AVL数, 红黑树**增加稳定性。

### 1. 二叉排序树的定义

**二叉排序树(Binary Sort Tree):**
1. 如果它的左子树不空, 则左子树上所有的节点都小于它的根节点的值(注意这里的根节点是相对的)
2. 如果它的右子树不空, 则有姿势上所有节点都大于它的根节点
3. 它的左右子树也分别是二叉排序树

![binarysorttree](/image/binarysorttree.png)

当对这颗树进行中序遍历时, 其结果将从小到大排序。

### 2. 查询操作

二叉排序树的查找时间复杂度为**O(lg n)**, 查找使用二分法。

> 例如: 要在上图找到元素37, 只需要四步即可。

1. 找到根元素22, 发现37>22, 所以淘汰左子树(因为左子树一定都比根节点小), 进入右子树;
2. 再找到右子树的根节点35, 直接淘汰左子树;
3. 再找到41, 37<44, 所以进入左子树;
4. 得到37

### 3. 插入操作

插入操作, 也是要先利用二分查找, 找到合适的位置, 再插入元素。所以插入速度相比链表较慢。

> 例如: 要在上图中插入元素5,

1. 找到根元素22, 发现5<22, 进入左子树;
2. 找到9, 发现5<9, 进入左子树;
3. 找到4, 发现5>4, 进入右子树;
4. 找到6, 发现5<6, 进入左子树, 发现没有左子树, 所以将元素5作为6的左子树根节点。

### 4. 删除操作

从二叉排序树中删除一个元素主要分为三种情况:

![binarysorttree](/image/binarysorttree.png)

1. 删除的元素时叶节点, 这时可以直接删除。比如要删除的值为1, 删除它对树没有任何影响;

2. 删除的元素仅有左孩子或者仅有右孩子, 直接让其孩子顶替它即可。比如要删除元素为35, 只需要用41顶替即可;

3. 删除元素既有左孩子又有右孩子, 这是删除操作就相对复杂。有一种好的方式就是找到它的前驱或者后继来代替它。比如要删除元素9, 就用6或者13代替它即可。

### 二叉排序树的问题

一个很普通的二叉排序树也会出现不平衡问题, 如果插入的数据都在数的一侧, 就会导致树的深度迅速增大, 每次二分查找可以排除的数据很少, 从而导致查询速度下降:

![binarysorttree_question](/image/binarysorttree_problem.png)

为了解决这种问题, 就需要在元素插入时进行修正, 也就是使用**平衡二叉树AVL和红黑树**。