## Java集合基础: 平衡二叉树(AVL Tree)

我们之前学习了二叉排序树, 它很好的平衡了插入与查找的效率, 但是不平衡的二叉排序树效率很低。AVL就是解决二叉树不平衡的问题。

### 1. AVL定义

`平衡二叉树(Self-Balancing Binary Search Tree或Height-Banlanced Binary Search Tree)`是一种二叉排序树, 其中每一个节点的左子树和右子树高度最多为1。

它是一种高度平衡的二叉排序树。也就是说, 要么它是一颗空树, 要么它的左子树和右子树都是平衡二叉树, 并且左子树和右子树的深度之差的绝对值不超过1。

二叉树上节点的左子树深度减去右子树深度的值称为**平衡因子BF(Balance Factor),**那么平衡二叉树上所有节点的平衡因子只可能是-1,0,1。

![noavl](/image/noavl.png)

上图就不是一个AVL树, 因为节点18的左子树高度为2, 右子树的高度为0, 高度差大于1。

我们可以通过一定的手段调整为, 平衡二叉树:

![avl1](/image/avl1.png)

### 2. 实现原理

我们从上图可以知道, 当我们在插入新节点之后, 需要遵守二叉排序树的规则, 但是又不能出现不平衡的情况。**所以就需要通过平衡因子来判断是否新节点会导致父节点或者祖节点"不平衡"。**

平衡二叉树构建的基本思想就是在二叉排序树插入节点时, 先检查是否破坏了树的平衡性, 如果是, 则找出**最小不平衡子树**。在保证二叉排序树的特性前提下(也就是左子树都小于根节点, 右子树都大于根节点), 调整最小不平衡子树中各节点之间的连接关系, 进行相应的旋转, 使之成为新的平衡子树。

> **最小不平衡子树**是指距离插入节点最近的, 并且平衡因子的绝对值大于1的节点为根的子树。

在代码中, 就是在递归的插入元素时, 递归判断每一个节点的平衡因子, 递归的维护平衡, 从而使得整棵树始终保持平衡。这种方式就是**左旋和右旋**。

#### 2.1 右旋

**当插入的节点在不平衡节点的左侧和左侧(RR)时, 我们利用右旋在实现平衡。**

如下图, 插入一个新节点之后出现不平衡:

![noavl2](/image/noavl2.png)

根据二叉排序树的性质, 它们之间的大小关系为:

> T1 < z < T2 < x < T3 < y < T4

此时我们发现, 它的最小不平衡子树就是以y为根节点的树。

右旋就是将x节点的右子树先拿掉, 然后让x节点的右孩子等于y节点, 最后y节点的左孩子等于刚刚拿掉的x节点的右孩子。

![avl_ll_1](/image/avl_ll_1.png)
![avl_ll_2](/image/avl_ll_2.png)
![avl_ll_3](/image/avl_ll_3.png)

可以看到, 经过右旋之后, 二叉树重新恢复平衡, 并且上面的大小关系也没有发生改变。

而且添加节点的过程是递归, 所以右旋之后的子树的父节点和祖节点也会进行相应的右旋或者左旋知道达到平衡状态。

右旋代码如下:

```java
/**
 * LL
 *
 * / 对节点进行右旋转操作，返回右旋转之后新的根节点
 * /        y                            x
 * /       / \                         /   \
 * /      x   T4     向右旋转(y)      z     y
 * /     / \       -------------->  / \   /  \
 * /    z  T3                      T1 T2 T3  T4
 * /   / \
 * /  T1 T2
 */
private Node rightRotate(Node y) {
    Node x = y.left;
    // 保存x节点的右子树，即使右子树为空，也没关系
    Node t3 = x.right;

    // 右旋
    x.right = y;
    // 将原本x的右子树放在y的左子树的位置
    y.left = t3;

    // 更新height
    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
    return x;
}
```

例如我们将数组`int[] a = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8}`构建成一颗二叉排序树。如下:

![binarysorttree_array](/image/binarysorttree_array.png)
![avl_ll_1](/image/avl_ll_1.png)

这样查找的效率会很低, 树的高度为8, 而且大多数只有一个孩子, 所以我们利用左旋, 将它变成AVL树。







