## Java集合基础: 树与二叉树

### 1. 树的定义

**树(Tree)**是n(n>=0)个节点的有限集。n=0时称为**空树**。

在任意一颗非空数中:
1. 有且仅有一个特定的节点称为**跟根(Root)**的节点;
2. 当n>1时, 其余节点可分为m个互不相交的有限集, 其中每一个集合本身又是一棵树, 并且称为根的**子树(SubTree)**。

如图:

![tree](/image/tree.png)

注意: 树的每个节点往下都是一颗子树, 而且这些子树不能相交。

![notree](/image/notree.png)

### 2. 树的相关概念

#### 2.1 节点分类

1. **树的节点拥有的子树个数称为节点的度(Degree)。**
2. **度为0的节点称为叶节点(Leaf)或终端节点; 度不为0的节点称为分支节点。**
3. **树的度是树内各节点的度的最大值。**

如下图, A节点为根节点, G, H, I, J, F为叶节点, 其余都是内部节点, 这个树的度为3.

![treedegree](/image/treedegree.png)

#### 2.2 深度

节点的**层次(Level)**从根开始定义, 根为第一层, 根的孩子为第二层。若某节点在第L层, 则其子树的根就在第L+1层。树中节点的最大层次称为树的**深度(Depth)或高度**。

![treedepth](/image/treedepth.png)

#### 2.3 有序树, 无序树

如果将树中节点的各子树看成从左至右是有次序的, 不能互换的, 则称该树为有序树, 否则称为无序树。

### 3. 二叉树

**二叉树(Binary Tree)**是n(n>=0)个节点的有限集合, 二叉树每个节点的度必须<=2。

![binarytree](/image/binarytree.png)

#### 3.1 二叉树遍历

**二叉树遍历(traversing binary tree)**是指从根节点出发, 按照某种次序依次访问二叉树中所有节点, 使得每个节点被访问一次且只访问一次。

对于下面的三种排序, 其实我们都可以当做递归来判断。每次都根据根节点分为左右子树, 然后再根据规则再去拆分左右子树, 直到最后只有叶子节点(此时可以看做只有根节点的数)。

**也就是说, 我们从根节点开始不断的划分左右子树, 直到最后无法划分, 开始根据不同的规则排序。**

##### 3.1.1 DLR前序遍历(后面的文章会详细介绍)

遍历规则:
> 若二叉树为空, 则操作返回; 否则先访问根节点, 然后前序遍历左子树, 再前序遍历右子树。

**根在前, 从左往右, 一棵树的根永远在左子树前面, 左子树永远在右子树前面**

如下图,前序遍历结果为: A->B->D->G->H->E->I->F

![binarytree_before](/image/binarytree_before.png)

##### 3.1.2 LDR中序遍历(后面的文章会详细介绍)

遍历规则:
> 若二叉树为空, 则操作返回; 否则先从根节点开始(注意并不是先访问根节点), 中序遍历根节点的左子树, 然后访问根节点, 最后中序遍历右子树。

**根在中, 从左往右, 一棵树的左子树永远在根前面, 根永远在右子树前面**

如下图, 中序遍历结果为: G->D->H->B->A->E->I->C->F

![binarytree_middel](/image/binarytree_middel.png)


##### 3.1.3 LRD后序遍历(后面的文章会详细介绍)

遍历规则:
> 若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。

**根在后, 从左往右, 一棵树的左子树永远在右子树前面, 右子树永远来根前面**

如下图, 后序遍历结果为: G->H->D->B->I->E->F->C->A

![binarytree_after](/image/binarytree_after.png)