## Java集合基础: 红黑树(RB Tree)

红黑树与AVL数的思想是类似的, 都是在插入过程中对二叉排序树进行调整, 从而提升性能, 它的增删改查又可以在**O(lg n)**内完成。

红黑树是比较复杂的一种数据结构, 必须要自己动手去画图，才能理解。

### 1. 红黑树的性质

大前提: **红黑树是一颗二叉排序树。**并且满足以下特点:

1. 每个节点或者是黑色, 或者是红色;
2. 根节点是黑色;
3. 每个叶子节点(NULL)是黑色。**注意:这里的叶子节点, 是指的为空的叶子节点**;
4. 如果一个节点是红色的, 则它的两个子节点都是黑色的, 不能有两个连续的红色节点;
5. 从任意一个节点到其每个叶子节点的路径中包含相同数量的黑色节点;

上面的5条性质作为限制, 即可避免二叉查找树退化成单链表的情况。**但是仅仅避免退化的情况还不够, 还要考虑某个节点到其每个叶子节点路径长度问题。**

如果某些路径长度过长, 那么在这些路径上进行增删查操作时, 效率也会大大降低。这个时候就用到了性质4和性质5, 可以保证任意节点到其每个叶子节点路径最长不会超过最短路径的2倍。原因如下:

> **当某条路径最短时, 这条路径必然都是由黑色节点构成。当某条路径最长时, 这条路径必然是由红色和黑色节点相间构成(这是因为性质4: 不允许有两个连续的红色节点)。而性质5又限定了从任意节点到每个叶子节点的所有路径必须包括相同数量的黑色节点。** <br>
> **也就是说, 在路径最长的情况下, 路径上红色节点数量=黑色节点数量。该路径长度为两倍的黑色节点数量, 也就是最短路径长度的2倍。**

![rb_tree1](/image/rb_tree1.png)

上图从根节点M出发到其叶子节点的最长和最短路径。最长路径有4条:

1. `M -> Q -> O -> N`
2. `M -> Q -> O -> P`
3. `M -> Q -> Y -> X`
4. `M -> Q -> Y -> Z`

长度为4, 最短路径为`M -> E`, 长度为2。最长路径的长度正好为最短路径长度的2倍。


### 2. 红黑树操作

红黑树的基本操作就是查找, 删除, 插入等。因为红黑树本身就是二叉查找树, 所以查找就很简单了, 遍历二叉排序树即可。

那么最难的就是红黑树的插入和删除操作了。在理解这些操作之前, 必须要知道树的旋转操作, 也就是左旋右旋。这个我们在AVL树([平衡二叉树](/Java_base/collection/collection_avltree.md))已经说过了。

#### 2.1 红黑树插入

首先, 红黑树的插入过程与二叉查找树插入过程基本类似, 但是红黑树在插入新节点之后需要进行调整, 来满足红黑树的5条性质。

- 红黑树节点的颜色要么是红色, 要么是黑色; 

    > 在插入新节点的的颜色一定是红色, 原因很简单, 如果插入的节点是黑色必然导致, 这个节点所在的路径比其他路径多出一个黑色节点, 就需要进行调整; 如果是红色, 那么只要它的父节点是黑色就不需要调整。

下面分析插入红色节点后红黑树的情况。将可能出现五种情况, 分别如下:

##### 2.1.1 插入的新节点是根节点

如果插入的新节点N是根节点, 那么根据性质2(根节点是黑色), 直接把新节点N变成黑色, 此时所有路径上的黑色节点都是1, 也满足性质5(从任意节点到其叶子节点所有路径包含相同的黑色节点)。

##### 2.1.2 插入的新节点的父节点是黑色

插入的新节点N, 它的父节点是黑色。这种情况下, 性质4(每个红色节点必须有两个黑色子节点)和性质5也是满足的, 不需要调整。 
**因为默认红色节点一定有两个为NULL的叶子节点, 并且是黑色的。**

##### 2.1.3 插入的新节点的父节点是红色, 叔叔节点是红色

新节点N的父节点P是红色, 也就是说它的祖父节点G必然是黑色。由于存在两个连续的红色, 所以性质4不满足, 需要进行调整。

这种情况下, 我们先将父节点P和叔叔节点U变成黑色, 再把祖父节点变成红色。此时经过G的路径上的黑色节点数量不变, 性质5仍然满足。但是要注意的时两点:

1. 如果祖父节点是根节点的话, 通过上面的操作, 导致变成红色, 所以不满足性质2, 此时就需要进行旋转, 保证根节点是黑色的;

2. 如果祖父节点的父节点也是红色, 那么就需要不断的递归向上调整。

![rb_tree2](/image/rb_tree2.png)

##### 2.1.4 插入的新节点的父节点是红色, 叔叔节点是黑色

如果是这种情况, 又要分为下面4中情况:

1. N的父节点P是红色, 叔叔节点U是黑色, N是P的右孩子, 而P是G的左孩子;

2. N的父节点P是红色, 叔叔节点U是黑色, N是P的左孩子, 而P是G的左孩子。

3. N的父节点P是红色, 叔叔节点U是黑色, N是P的右孩子, 而P是G的右孩子;

4. N的父节点P是红色, 叔叔节点U是黑色, N是P的左孩子, 而P是G的右孩子;


我们只对1, 2两种情况进行分析, 因为1, 2与3, 4情况是正好相反的, 所以操作上直接进行反向即可。

> 但是要注意的是, 上面的4种情况, N节点可能并不是相信插入的节点, 因为N的父节点是红色, 而叔叔节点却是黑色, 所以一定是插入新节点之后, 已经对树进行调整后的结果, 导致了上面情况的出现。

**情况1:**

N的父节点P是红色, 叔叔节点U是黑色, N是P的右孩子, 而P是G的左孩子; 

此时先对父节点P进行左旋, 调整N和P的位置, 然后按照情况2进行处理, 来恢复性质4.

![rb_tree3](/image/rb_tree3.png)

**情况2:**

N的父节点P是红色, 叔叔节点U是黑色, N是P的左孩子, 而P是G的左孩子; 此时对祖父G进行右旋, 调整P和G的位置, 并且父节点和祖父节点交换颜色, 即可。

![rb_tree4](/image/rb_tree4.png)


##### 2.1.5 插入操作总结

我们从上面几种情况可以看到, 2.1.1和2.1.2都是比较简单的, 其他的稍微复杂一些, 但是可以发现复杂的情况的区别在于叔叔节点的颜色, 如果叔叔节点是红色, 直接变色即可; 如果叔叔节点为黑色, 则需要根据情况进行旋转, 再变色。

![rb_tree5](/image/rb_tree5.png)


#### 2.2 红黑树的删除

相比于插入操作, 红黑树的删除操作更为复杂。因为删除操作首先要确定待删除节点有几个孩子, 如果有两个孩子, 不能直接删除。而是要先找到该节点的前驱(该节点左子树中最大的节点)或者后继(该节点右子树中的最小节点), 然后将前驱或者后继的值复制到要删除的节点中, 最后再将前驱或后继删除。

因为前驱和后继最多只有一个孩子节点, 这样我们就把原来要删除的节点有两孩子的问题转化为只有一个孩子节点的问题。

**红黑树删除操作的复杂度在于删除节点的颜色:**

1. 当删除的节点是红色时, 直接拿其孩子节点补上空位即可。 因为删除红色节点, 仍然满足性质5(从任意节点到其叶子节点的所有路径包含相同数量的黑色节点)。

2. 当删除的节点是黑色时, 那么性质5就被破坏了, 如果该节点的孩子为红色, 那么直接替换其删除节点, 并将孩子节点变成黑色; 但是如果孩子节点也是黑色, 那么处理起来就要复杂, 分为6种情况。

假设最终被删除的节点为x(最多只有一个孩子节点), 其孩子节点为N, X的兄弟节点为S, S的左节点是SL, 右节点是SR。

![rb_tree6](/image/rb_tree6.png)

##### 2.2.1 删除的节点是根节点, 并且左右孩子均为空

这种情况, 直接删除节点, 用空节点替换完成删除操作。

##### 2.2.2 S为红色, 其他节点为黑色

这种情况下, 可以对N的父节点P进行左旋操作, 然后互换P与S的颜色, 但是并没有调整完毕, 经过节点P和N的路径删除前有3个黑色节点(P -> X -> N), 现在只有两个了(P -> N)。所以性质5不满足, 我们按照**情况2.2.4, 2.2.5, 2.2.6**进行调整。

![rb_tree7](/image/rb_tree7.png)

##### 2.2.3 N的父节点, 兄弟节点S和S的孩子节点都为黑色

这种情况下, 可以简单把N的兄弟节点S变成红色, 所有经过S的路径比之前少了一个黑色节点, 这样经过N的路径和经过S的路径黑色节点数量一致。但是经过P的路径比不经过P的路径少了一个黑色节点, 所以需要通过**情况2.2.2**进行处理。

![rb_tree8](/image/rb_tree8.png)

> 我们其实已经看出来了, 这个情况经过调整后, 就出现了情况2.2.2的问题, 所以通过2.2.2的处理即可

##### 2.2.4 N的父节点是红色, 它的兄弟节点S和S的孩子节点为黑色

这种情况比较简单, 我们只需要交换父节点P和兄弟节点S的颜色, 就又出现了**情况2.2.3**的问题, 所以直接通过**情况2.2.3**解决即可。

##### 2.2.5 S为黑色, SL为红色, SR为黑色

这种情况, N的父节点P可红可黑, 且N是P的左孩子。这种情况下对S进行右旋操作, 并且互换SL和SR的颜色。此时所有路径上的黑色数量仍然相等, N兄弟节点S变成了SL, 而SL的右孩子变成为红色, 那么我们通过**情况2.2.6**处理

![rb_tree9](/image/rb_tree9.png)

##### 2.2.6 S为黑色, SR为红色

N的父节点P可红可黑, 并且N是P的左孩子。这种情况下, 我们对P进行左旋操作, 并且互换P和S的颜色, 并将SR变为黑色。因为P变为黑色, 所以经过N的路径过了一个黑色节点, 经过N的路径上的黑色节点与删除前一致。而对于不经过N的路径, 则又要分两种情况:

1. 该路径经过N的新兄弟节点SL, 那它必然经过S和P, 而S和P现在只是交换颜色, 对于经过SL的路径不影响;

2. 该路径经过N的新叔叔节点SR, 那它之前必然经过P, S和SR, 而现在它只经过S和SR。在对P进行左旋, 并与S换色后, 经过SR的路径少了一个黑色节点, 不满足性质5。而且, 由于S的颜色可红可黑, 如果S是红色的话, 会与SR形成连续的红色节点, 又不满足性质4。

此时只需将SR由红色变为黑色即可同时恢复性质4和性质5。

![rb_tree10](/image/rb_tree10.png)

##### 2.2.7 删除操作总结

虽然红黑树的情况比较多, 但是我们仔细观察可以发现一些规律。

![rb_tree11](/image/rb_tree11.png)

上图可以看到, 5种情况下。每一种情况的变化, 都能够作为另一种的解决方案。

例如: 情况三进行操作变成情况二; 情况四进行操作变成情况三; 情况五进行操作变成情况六。

所以删除情况虽多, 但是每种情况都可以联系在一起。

