## 深入分析synchronized的实现原理

之前我们学习了有关`synchronized`的基本功能, 以及用法。

> `synchronized`可以保证方法或者代码块在运行时, 同一时刻只有一个方法可以进入, 同时还可以保证共享变量的内存可见性。(对于可见性这里在这边文章中学习到[volatile](java_base/concurrent/promote/thread_volatile.md))

Java中每一个对象都可以作为锁, 这是`synchronized`实现同步的基础:
1. 普通同步方法, 锁是当前实例对象
2. 静态同步方法, 锁时当前类的class对象
3. 同步方法块, 锁是括号里面的对象

我们知道使用`synchronized`时, 会调用`monitorenter`和`monitorexit`指令来实现同步。而了解它的原理之前, 需要知道两个重要的概念: **Java对象头**, **Monitor**。

### Java对象头, monitor

#### Java对象头

`synchronized`用的锁时存在Java对象头里的。在Hotspod虚拟机的对象头主要包括两部分:**Mark Word(标记字段), Klass Pointer(类型指针)。**

- `Klass Point`是对象指向它的类数据的指针, 虚拟机通过这个指针来确定这个对象是哪个类的实例; 

    > 我们一般new一个实例, Object o = new Object(); 其中new Object()的类信息时存在堆内存中的, 而 o 是存在栈内存, 它会指向堆内存的实例地址。

- `Mark Word`用于存储对象自身的运行时数据, 它是实现轻量级锁和偏向锁的关键。

    > Mark Word用于存储是对象自身的数据, 如**哈希码(HashCode), GC分代年龄, 锁状态标志, 线程持有的锁, 偏向线程ID, 偏向时间戳等。**

Java对象头一般占有两个机器码(在32位虚拟机中, 1机器码=4字节, 也就是32bit), 但是如果对象是数组类型, 则需要三个机器码, 因为JVM虚拟机可以通过Javad对象的元数据信息确定Java对象的大小, 但是无法从数组的元数据来确认数组的大小, 所以用一块来记录数组长度。

Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据, 它会根据对象的状态复用自己的存储空间, 也就是说, Mark Word会随着程序的运行发生改变。


#### Monitor

Monitor可以理解为就是一个对象, 所有的Java对象是天生的Monitor, 因为在Java的设计中, 每一个Java对象都带有这把锁, 所以它又被称为内部锁或者Monitor锁。

Monitor是线程私有的数据结构, 每一个线程都有一个可用的monitor record列表, 同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联(对象头的markword中的LockWord指向monitor的起始地址), 同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识, 表示该锁被这个线程占用。

### 锁升级

我们知道`synchronized`是重量级锁, 效率不高。但是JDK1.6对`synchronized`的实现进行各种优化, 这就是锁升级。

**锁主要存在4种状态, 依次是: 无锁->偏向锁->轻量级锁->重量级锁**, 它们会随着线程的竞争而逐渐升级。使用锁升级的目的是为了提高获得锁和释放锁的效率。

下面先介绍一下这几种状态锁的含义。

#### 无锁

在多线程开发中有很多"无锁"的概念, 我们经常说CAS也是无锁化, 只是语义不同而已。在锁升级的过程中, 无锁的意思就代表这个对象刚刚创建, 没有被任何线程获取到monitor。通俗的来说就是 new Object()的过程。

#### 自旋锁

线程的阻塞和唤醒会产生线程的上下文切换, 这种频繁的阻塞和唤醒对CPU来说是影响效率的, 会给系统的并发性能带来很大的压力。而且在很多情况下, 对象锁的锁状态只会持续很短一段时间,为了这一段很短的时间频繁的阻塞和唤醒线程是非常不值得的。所以引入了自旋锁。

所谓自旋锁, 就是让线程等待一段时间, 等待的方式就是不断循环判断是否可以获取锁。**要注意的是, 自旋等待不能替换阻塞, 虽然它可以避免线程切换带来的开销, 但是它占用了处理器的时间。** 如果持有锁的线程很快就释放了锁, 那么自旋的效率就非常好; 反之, 自选的线程就会白白消耗掉CPU的资源, 这样反而会带来性能上的浪费。

所以说, 自旋等待的时间或者说自旋的次数必须要有一个限度, 如果自旋超过了定义的时间仍然没有获取到锁, 则就会被挂起。

> 在JDK1.6中默认开启, 同时自旋的默认次数为10次, 可以通过参数 `-XX:PreBlockSpin`来调整, 如果通过这个命令来调整自旋次数, 会带来很多问题。<br/>
> 假如将参数调整为10, 如果线程在自旋10次退出后,正好释放了锁, 那么不仅还需要唤醒它, 还白白浪费了CPU的资源。

所以又出来了自适应的自旋锁。

#### 自适应自旋锁

自适应意味着自旋的次数不再是固定的。它是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。

> 线程如果自旋成功了, 那么下次自旋的次数就会更多, 因为JVM认为既然上次成功了, 那么此次自旋也很有可能再次成功, 那么JVM就会允许自旋的次数更多。<br/>
> 反之, 如果对于某个锁, 很少有自锁能成功的, 那么之后的线程在获取不到这个锁时就会减少自旋的次数, 甚至省略自旋过程, 以免浪费处理器资源。

#### 锁消除

在某些情况下, JVM检查到不可能存在共享数据竞争, 这是JVM会对这个同步锁进行锁消除。锁消除可以节省毫无意义的请求锁的时间。

> 但是这里有个问题, 是否需要加锁, 难道程序员不知道吗? 我们明明知道不存在数据竞争的代码块前加上同步吗?

 事实并非如此, 因为JDK有很多内置的API, 会有同步操作。例如: `StringBuffer`, `Vector`, `HashTable`等, 这个时候会存在隐形的加锁操作。

 比如: StringBuffer的append()方法, Vector的add()方法:

    ```java
    public void vectorTest(){
        StringBuffer<String> sb = new StringBuffer();
        for(int i = 0 ; i < 10 ; i++){
            sb.append(i + ":");
        }

        System.out.println(sb.toString());
    }
    ```

在上面的代码中, 并不存在线程竞争问题, JVM就会将StringBuffer内部的加锁操作消除。

#### 偏向锁

在某种情况下, 一个所对象并不会发生被多个线程访问的情况, 更多的是被同一个线程访问。那么如果一个锁对象每次都被同一个线程访问, 根本没有发生并发, 但是每次都进行加锁, 那就耗费了性能, 所以引出了偏向锁。

也就是说, 当每次获取锁的线程都是同一个, 那就直接执行同步代码, 否则就有可能升级为轻量级锁。 它的处理流程如下:

**获取锁:**
1. 检测Mark Word是否是可偏向状态, 即是否为偏向锁1, 锁标识位是01;
2. 如果是可偏向状态, 则判断线程ID是否为当前线程ID, 如果是, 则执行步骤5, 否则执行步骤3;
3. 如果线程ID不为当前线程ID, 则通过CAS操作竞争锁, 如果竞争成功, 则将Mark Word的线程ID替换为竞争成功的线程ID, 否则执行步骤4;
4. 通过CAS竞争锁失败就意味着当前存在多线程竞争情况, 偏向锁升级为轻量级锁, 然后继续往下执行同步代码;
5. 执行同步代码块

**释放锁:**

偏向锁的释放机制是, 线程不会主动释放偏向锁, 需要等待其他线程来竞争。
1. 暂停拥有偏向锁的线程, 判断锁对象是否还处于被锁定状态;
2. 撤销偏向锁, 恢复到无锁状态(01)或者升级为轻量锁状态(00)

![synchronized_upgrade1](/image/synchronized_upgrade1.png)

#### 轻量级锁

当关闭偏向锁功能或者多个线程竞争偏向锁会导致偏向锁升级为轻量级锁。

> 轻量级锁为什么可以提升性能? 或者说它提升性能的一依据是: **对于绝大部分的锁, 在整个程序执行阶段都是不会存在竞争的**, 如果打破了这个依据, 那么除了线程互斥, 还有额外的CAS操作, 因此在有多线程竞争的情况下, 轻量级锁比重量级锁更慢。

它的处理流程如下:

**获取锁:**
1. 判断当前对象是否处于无锁状态(也就是偏向锁标识位0, 锁标志位01), 如果是, 则JVM先将当前线程的私有栈中建立一个锁记录(Lock Record)的空间, 用于存储锁对象目前的Mark Word的拷贝(这份拷贝加了一个`Displaced`前缀, 即Displaced Mark Word); 否则执行步骤3;
2. JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针, 如果成功表示获取锁, 则将锁标志位变成00(轻量级锁状态), 执行同步操作; 如果失败执行步骤3;
3. 判断当前对象的Mark Word是否指向当前对象的栈, 如果是, 则表示当前线程已持有锁, 则直接执行同步代码; 否则只能说明该锁对象已经被其他线程抢占了, 此时轻量级锁需要升级为重量级锁, 锁标志位变成10, 后面等待的线程将会进入阻塞状态。

**释放锁:** 轻量级锁的释放也是通过CAS操作来进行的。
1. 取出在获取轻量级锁保存在`Displaced Mark Word`中的数据;
2. 用CAS操作将取出的数据替换当前对象的Mark Word, 如果成功, 则说明释放锁成功, 否则执行步骤3;
3. 如果CAS操作替换失败, 说明有其他线程尝试获取锁, 则需要在释放锁的同时唤醒其他被阻塞的线程。

![synchronized_upgrade2](/image/synchronized_upgrade2.png)

### 总结

虽然`synchronized`在jdk1.6之后优化了很多, 但是我们从上面可以看到, 它的机制还是不变的。`synchronized`仍然是基于JVM来进行同步操作, 这是一个黑盒操作, 外面是无法对其进行灵活的改动, 再加上在高并发的环境中, 它的并发效率依然很低。

这也是后面会出来`J.U.C`工具包的原因。利用AQS来实现大量并发工具类。


















